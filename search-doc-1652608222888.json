[{"title":"Introduction","type":0,"sectionRef":"#","url":"docs/","content":"","keywords":""},{"title":"What is middy​","type":1,"pageTitle":"Introduction","url":"docs/#what-is-middy","content":"Middy is a very simple middleware engine that allows you to simplify your AWS Lambda code when using Node.js. If you have used web frameworks like Express, then you will be familiar with the concepts adopted in Middy and you will be able to get started very quickly. A middleware engine allows you to focus on the strict business logic of your Lambda and then attach additional common elements like authentication, authorization, validation, serialization, etc. in a modular and reusable way by decorating the main business logic. "},{"title":"A quick example​","type":1,"pageTitle":"Introduction","url":"docs/#a-quick-example","content":"Code is better than 10,000 words, so let's jump into an example. Let's assume you are building a JSON API to process a payment: handler.js // import core import middy from '@middy/core' // esm Node v14+ //const middy = require('@middy/core') // commonjs Node v12+ // import some middlewares import jsonBodyParser from '@middy/http-json-body-parser' import httpErrorHandler from '@middy/http-error-handler' import validator from '@middy/validator' // This is your common handler, in no way different than what you are used to doing every day in AWS Lambda const baseHandler = async (event, context) =&gt; { // we don't need to deserialize the body ourself as a middleware will be used to do that const { creditCardNumber, expiryMonth, expiryYear, cvc, nameOnCard, amount } = event.body // do stuff with this data // ... const response = { result: 'success', message: 'payment processed correctly'} return {statusCode: 200, body: JSON.stringify(response)} } // Notice that in the handler you only added base business logic (no deserialization, // validation or error handler), we will add the rest with middlewares const inputSchema = { type: 'object', properties: { body: { type: 'object', properties: { creditCardNumber: { type: 'string', minLength: 12, maxLength: 19, pattern: '\\\\d+' }, expiryMonth: { type: 'integer', minimum: 1, maximum: 12 }, expiryYear: { type: 'integer', minimum: 2017, maximum: 2027 }, cvc: { type: 'string', minLength: 3, maxLength: 4, pattern: '\\\\d+' }, nameOnCard: { type: 'string' }, amount: { type: 'number' } }, required: ['creditCardNumber'] // Insert here all required event properties } } } // Let's &quot;middyfy&quot; our handler, then we will be able to attach middlewares to it const handler = middy(baseHandler) .use(jsonBodyParser()) // parses the request body when it's a JSON and converts it to an object .use(validator({inputSchema})) // validates the input .use(httpErrorHandler()) // handles common http errors and returns proper responses module.exports = { handler } Copy "},{"title":"Why?​","type":1,"pageTitle":"Introduction","url":"docs/#why","content":"One of the main strengths of serverless and AWS Lambda is that, from a developer perspective, your focus is mostly shifted toward implementing business logic. Anyway, when you are writing a handler, you still have to deal with some common technical concerns outside business logic, like input parsing and validation, output serialization, error handling, etc. Very often, all this necessary code ends up polluting the pure business logic code in your handlers, making the code harder to read and to maintain. In other contexts, like generic web frameworks (fastify, hapi, express, etc.), this problem has been solved using the middleware pattern. This pattern allows developers to isolate these common technical concerns into&quot;steps&quot; that decorate the main business logic code. Middleware functions are generally written as independent modules and then plugged into the application in a configuration step, thus not polluting the main business logic code that remains clean, readable, and easy to maintain. Since we couldn't find a similar approach for AWS Lambda handlers, we decided to create middy, our own middleware framework for serverless in AWS land. "},{"title":"Bundling Lambda packages","type":0,"sectionRef":"#","url":"docs/best-practices/bundling","content":"Bundling Lambda packages If you're using the Serverless framework, checkout serverless-bundle. It's a wrapper around Webpack, Babel, and a bunch of other dependencies.","keywords":""},{"title":"Connection reuse","type":0,"sectionRef":"#","url":"docs/best-practices/connection-reuse","content":"Connection reuse Be sure to set the following environment variable when connecting to AWS services: AWS_NODEJS_CONNECTION_REUSE_ENABLED=1 Copy This allows you to reuse the first connection established across lambda invocations. See Reusing Connections with Keep-Alive in Node.js","keywords":""},{"title":"Intro","type":0,"sectionRef":"#","url":"docs/best-practices/intro","content":"Intro In this section you will find some common tips and tricks to ensure you don't hit any performance or security issues. Did we miss something? Let us know.","keywords":""},{"title":"Internal Context","type":0,"sectionRef":"#","url":"docs/best-practices/internal-context","content":"Internal Context Middy is built to be async even at it's core. Middlewares can set promises to internal. This approach allows them to be resolved together just when you need them. import middy from '@middy/core' import {getInternal} from '@middy/util' const config = { internal: new Proxy({}, { get: (target, prop, receiver) =&gt; { // ... return Reflect.get(...arguments) }, set: (obj, prop, value) =&gt; { // ... ie if `prop` changes, trigger something obj[prop] = value return true } }) } export const handler = middy() // Incase you want to add values on to internal directly .before((async (request) =&gt; { request.internal = { env: process.env.NODE_ENV } })) .use(sts(...)) .use(ssm(...)) .use(rdsSigner(...)) .use(secretsManager(...)) .before(async (request) =&gt; { // internal == { key: 'value' } // Map with same name Object.assign(request.context, await getInternal(['key'], request)) // -&gt; context == { key: 'value'} // Map to new name Object.assign(request.context, await getInternal({'newKey':'key'}, request)) // -&gt; context == { newKey: 'value'} // get all the values, only if you really need to, // but you should only request what you need for the handler Object.assign(request.context, await getInternal(true, request)) // -&gt; context == { key: 'value'} }) .handler(async (event, context, { signal }) =&gt; { }) Copy","keywords":""},{"title":"Small node_modules","type":0,"sectionRef":"#","url":"docs/best-practices/small-node-modules","content":"Small node_modules Using a bundler is the optimal solution, but can be complex depending on your setup. In this case you should remove excess files from your node_modules directory to ensure it doesn't have anything excess shipped to AWS. We put together a .yarnclean file you can check out and use as part of your CI/CD process: .yarnclean # -- Middy.js -- # Dependencies **/ajv/docs **/ajv/lib **/ajv/.tonic_examples.js **/ajv-errors/src **/ajv-formats/src **/json-mask/bin **/json-mask/build **/json-mask/example **/json-mask/test **/json-mask/logo.png **/qs/.github **/qs/dist **/qs/test # DevDependencies **/@types **/@serverless/event-mocks ## Sub[/Sub] Dependencies **/bowser/src **/bowser/bundled.js **/dicer/bench **/dicer/test **/inherits/inherits_browser.js **/json-schema-traverse/.github **/json-schema-traverse/spec **/fast-deep-equal/es6 **/fast-deep-equal/react.js **/querystring/test **/react-native-get-random-values/android **/react-native-get-random-values/ios **/react-native-get-random-values/index.web.js **/react-native-get-random-values/react-native-get-random-values.podspec **/setprototypeof/test **/tslib **/uri-js/dist/esnext **/url/.zuul.yml **/url/test.js **/uuid/bin # Builds *.ts tsconfig.json *.js.map package-lock.json yarn.lock .travis.yml # Common .bin .cache .editorconfig .eslintignore .eslintrc .eslintrc.yml .gitattributes .npmignore AUTHORS LICENSE *.md *.txt Copy","keywords":""},{"title":"Profiling","type":0,"sectionRef":"#","url":"docs/best-practices/profiling","content":"","keywords":""},{"title":"Time​","type":1,"pageTitle":"Profiling","url":"docs/best-practices/profiling#time","content":" const defaults = { logger: console.log, enabled: true } const timePlugin = (opts = {}) =&gt; { const { logger, enabled } = { ...defaults, ...opts } const store = {} const start = (id) =&gt; { store[id] = process.hrtime.bigint() } const stop = (id) =&gt; { if (!enabled) return logger(id, Number.parseInt((process.hrtime.bigint() - store[id]).toString()) / 1000000, 'ms') } // Only run during cold start const beforePrefetch = () =&gt; start('total') const requestStart = () =&gt; { if (!store.init) { store.init = store.total stop('init') } else { start('total') } } const beforeMiddleware = start const afterMiddleware = stop const beforeHandler = () =&gt; start('handler') const afterHandler = () =&gt; stop('handler') const requestEnd = () =&gt; stop('total') return { beforePrefetch, requestStart, beforeMiddleware, afterMiddleware, beforeHandler, afterHandler, requestEnd } } export const handler = middy(timePlugin()) .use(eventLogger()) .use(errorLogger()) .use(httpEventNormalizer()) .use(httpHeaderNormalizer()) .use(httpUrlencodePathParametersParser()) .use(httpUrlencodeBodyParser()) .use(httpJsonBodyParser()) .use(httpCors()) .use(httpSecurityHeaders()) .use(validator({inputSchema})) .handler(()=&gt;{}) await handler() Copy This will log out something this: inputOutputLoggerMiddlewareBefore 0.156033 ms httpEventNormalizerMiddlewareBefore 0.073921 ms httpHeaderNormalizerMiddlewareBefore 0.095098 ms httpUrlencodePathParserMiddlewareBefore 0.036255 ms httpUrlencodeBodyParserMiddlewareBefore 0.038809 ms httpJsonBodyParserMiddlewareBefore 0.048383 ms httpContentNegotiationMiddlewareBefore 0.042311 ms validatorMiddlewareBefore 0.083366 ms handler 0.094875 ms validatorMiddlewareAfter 0.083601 ms httpSecurityHeadersMiddlewareAfter 0.19702 ms httpCorsMiddlewareAfter 0.080532 ms inputOutputLoggerMiddlewareAfter 0.066886 ms lambda 66.141835 ms Copy From this everything looks good. Sub 1ms for every middleware and the handler. But wait, that total doesn't look right. You're correct, total includes the initial setup time (or cold start time) for all middlewares. In this case validator is the culprit. The Ajv constructor and compiler do a lot of magic when they first run to get ready for later schema validations. This is why in the validator middleware we now support passing in complied schema and expose the default compiler in case you want to use it in a build step. We hope this feature will help to you in identify slow middlewares and improve your development experience. There is also a beforeRequest hook, but was left out of the example for dramatic effect. Additionally, you'll notice that each middleware shows a descriptive name. This is printing out the function name passed into middy core. If you've looked at the code for some the supported middlewares, you'll see these long descriptive variable names being set, then returned. This is why. "},{"title":"Memory​","type":1,"pageTitle":"Profiling","url":"docs/best-practices/profiling#memory","content":"import memwatch from '@airbnb/node-memwatch' const defaults = { logger: console.log } const memoryPlugin = (opts = {}) =&gt; { const { logger } = { ...defaults, ...opts } const store = {} const start = (id) =&gt; { store[id] = new memwatch.HeapDiff() } const stop = (id) =&gt; { logger(id, store[id].end()) } const beforePrefetch = () =&gt; start('total') const requestStart = () =&gt; { store.init = store.total stop('init') } const beforeMiddleware = start const afterMiddleware = stop const beforeHandler = () =&gt; start('handler') const afterHandler = () =&gt; stop('handler') const requestEnd = () =&gt; stop('total') return { beforePrefetch, requestStart, beforeMiddleware, afterMiddleware, beforeHandler, afterHandler, requestEnd } } export const handler = middy(memoryPlugin()) .use(eventLogger()) .use(errorLogger()) .use(httpEventNormalizer()) .use(httpHeaderNormalizer()) .use(httpUrlencodePathParametersParser()) .use(httpUrlencodeBodyParser()) .use(httpJsonBodyParser()) .use(httpCors()) .use(httpSecurityHeaders()) .use(validator({inputSchema})) .handler(()=&gt;{}) await handler() Copy "},{"title":"Alexa","type":0,"sectionRef":"#","url":"docs/events/alexa","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"Alexa","url":"docs/events/alexa#aws-documentation","content":"Using AWS Lambda with Alexa TODO "},{"title":"Example​","type":1,"pageTitle":"Alexa","url":"docs/events/alexa#example","content":"import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"API Gateway (HTTP)","type":0,"sectionRef":"#","url":"docs/events/api-gateway-http","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"API Gateway (HTTP)","url":"docs/events/api-gateway-http#aws-documentation","content":"Using AWS Lambda with Amazon API GatewayWorking with HTTP APIs TODO "},{"title":"Example​","type":1,"pageTitle":"API Gateway (HTTP)","url":"docs/events/api-gateway-http#example","content":"import middy from '@middy/core' import errorLoggerMiddleware from '@middy/error-logger' import inputOutputLoggerMiddleware from '@middy/input-output-logger' import httpContentNegotiationMiddleware from '@middy/http-content-negotiation' import httpContentEncodingMiddleware from '@middy/http-content-encoding' import httpCorsMiddleware from '@middy/http-cors' import httpErrorHandlerMiddleware from '@middy/http-error-handler' import httpEventNormalizerMiddleware from '@middy/http-event-normalizer' import httpHeaderNormalizerMiddleware from '@middy/http-header-normalizer' import httpJsonBodyParserMiddleware from '@middy/http-json-body-parser' import httpMultipartBodyParserMiddleware from '@middy/http-multipart-body-parser' import httpPartialResponseMiddleware from '@middy/http-partial-response' import httpResponseSerializerMiddleware from '@middy/http-response-serializer' import httpSecurityHeadersMiddleware from '@middy/http-security-headers' import httpUrlencodeBodyParserMiddleware from '@middy/http-urlencode-body-parser' import httpUrlencodePathParametersParserMiddleware from '@middy/http-urlencode-path-parser' import validatorMiddleware from 'validator' // or `middy-ajv` import warmupMiddleware from 'warmup' import inputSchema from './eventSchema.json' assert { type: 'json' } import outputSchema from './responseSchema.json' assert { type: 'json' } export const handler = middy({ timeoutEarlyResponse: () =&gt; { return { statusCode: 408 } } }) .use(warmupMiddleware()) .use(httpEventNormalizerMiddleware()) .use(httpHeaderNormalizerMiddleware()) .use( httpContentNegotiationMiddleware({ availableLanguages: ['en-CA', 'fr-CA'], availableMediaTypes: ['application/json'] }) ) .use(httpUrlencodePathParametersParserMiddleware()) // Start oneOf .use(httpUrlencodeBodyParserMiddleware()) .use(httpJsonBodyParserMiddleware()) .use(httpMultipartBodyParserMiddleware()) // End oneOf .use(httpSecurityHeadersMiddleware()) .use(httpCorsMiddleware()) .use(httpContentEncodingMiddleware()) .use( httpResponseSerializerMiddleware({ serializers: [ { regex: /^application\\/json$/, serializer: ({ body }) =&gt; JSON.stringify(body) } ], default: 'application/json' }) ) .use(httpPartialResponseMiddleware()) .use(validatorMiddleware({ inputSchema, outputSchema })) .use(httpErrorHandlerMiddleware()) .handler((event, context, { signal }) =&gt; { // ... }) Copy "},{"title":"API Gateway (WebSocket)","type":0,"sectionRef":"#","url":"docs/events/api-gateway-ws","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"API Gateway (WebSocket)","url":"docs/events/api-gateway-ws#aws-documentation","content":"Using AWS Lambda with Amazon API GatewayWorking with WebSocket APIs TODO "},{"title":"Example​","type":1,"pageTitle":"API Gateway (WebSocket)","url":"docs/events/api-gateway-ws#example","content":"import middy from '@middy/core' import wsJsonBodyParserMiddleware from '@middy/ws-json-body-parser' import wsResponseMiddleware from '@middy/ws-response' import wsRouterHandler from '@middy/ws-router' import { handler as connectHandler } from './handlers/connect.js' import { handler as disconnectHandler } from './handlers/disconnect.js' import { handler as defaultHandler } from './handlers/default.js' const routes = [ { routeKey: '$connect', handler: connectHandler }, { routeKey: '$disconnect', handler: disconnectHandler }, { routeKey: 'default', handler: defaultHandler } ] export const handler = middy() .use(wsJsonBodyParserMiddleware()) .use(wsResponseMiddleware()) .handler(wsRouterHandler(routes)) Copy "},{"title":"API Gateway (REST)","type":0,"sectionRef":"#","url":"docs/events/api-gateway-rest","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"API Gateway (REST)","url":"docs/events/api-gateway-rest#aws-documentation","content":"Using AWS Lambda with Amazon API GatewayWorking with REST APIs TODO "},{"title":"Example​","type":1,"pageTitle":"API Gateway (REST)","url":"docs/events/api-gateway-rest#example","content":"import middy from '@middy/core' import errorLoggerMiddleware from '@middy/error-logger' import inputOutputLoggerMiddleware from '@middy/input-output-logger' import httpContentNegotiationMiddleware from '@middy/http-content-negotiation' import httpContentEncodingMiddleware from '@middy/http-content-encoding' import httpCorsMiddleware from '@middy/http-cors' import httpErrorHandlerMiddleware from '@middy/http-error-handler' import httpEventNormalizerMiddleware from '@middy/http-event-normalizer' import httpHeaderNormalizerMiddleware from '@middy/http-header-normalizer' import httpJsonBodyParserMiddleware from '@middy/http-json-body-parser' import httpMultipartBodyParserMiddleware from '@middy/http-multipart-body-parser' import httpPartialResponseMiddleware from '@middy/http-partial-response' import httpResponseSerializerMiddleware from '@middy/http-response-serializer' import httpSecurityHeadersMiddleware from '@middy/http-security-headers' import httpUrlencodeBodyParserMiddleware from '@middy/http-urlencode-body-parser' import httpUrlencodePathParametersParserMiddleware from '@middy/http-urlencode-path-parser' import validatorMiddleware from 'validator' // or `middy-ajv` import warmupMiddleware from 'warmup' import inputSchema from './eventSchema.json' assert { type: 'json' } import outputSchema from './responseSchema.json' assert { type: 'json' } export const handler = middy({ timeoutEarlyResponse: () =&gt; { return { statusCode: 408 } } }) .use(warmupMiddleware()) .use(httpEventNormalizerMiddleware()) .use(httpHeaderNormalizerMiddleware()) .use( httpContentNegotiationMiddleware({ availableLanguages: ['en-CA', 'fr-CA'], availableMediaTypes: ['application/json'] }) ) .use(httpUrlencodePathParametersParserMiddleware()) // Start oneOf .use(httpUrlencodeBodyParserMiddleware()) .use(httpJsonBodyParserMiddleware()) .use(httpMultipartBodyParserMiddleware()) // End oneOf .use(httpSecurityHeadersMiddleware()) .use(httpCorsMiddleware()) .use(httpContentEncodingMiddleware()) .use( httpResponseSerializerMiddleware({ serializers: [ { regex: /^application\\/json$/, serializer: ({ body }) =&gt; JSON.stringify(body) } ], default: 'application/json' }) ) .use(httpPartialResponseMiddleware()) .use(validatorMiddleware({ inputSchema, outputSchema })) .use(httpErrorHandlerMiddleware()) .handler((event, context, { signal }) =&gt; { // ... }) Copy "},{"title":"Application Load Balancer","type":0,"sectionRef":"#","url":"docs/events/application-load-balancer","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"Application Load Balancer","url":"docs/events/application-load-balancer#aws-documentation","content":"Using AWS Lambda with an Application Load Balancer TODO "},{"title":"Example​","type":1,"pageTitle":"Application Load Balancer","url":"docs/events/application-load-balancer#example","content":"import middy from '@middy/core' import httpRouterHandler from '@middy/http-router' import errorLoggerMiddleware from '@middy/error-logger' import inputOutputLoggerMiddleware from '@middy/input-output-logger' import httpContentNegotiationMiddleware from '@middy/http-content-negotiation' import httpContentEncodingMiddleware from '@middy/http-content-encoding' import httpCorsMiddleware from '@middy/http-cors' import httpErrorHandlerMiddleware from '@middy/http-error-handler' import httpEventNormalizerMiddleware from '@middy/http-event-normalizer' import httpHeaderNormalizerMiddleware from '@middy/http-header-normalizer' import httpJsonBodyParserMiddleware from '@middy/http-json-body-parser' import httpMultipartBodyParserMiddleware from '@middy/http-multipart-body-parser' import httpPartialResponseMiddleware from '@middy/http-partial-response' import httpResponseSerializerMiddleware from '@middy/http-response-serializer' import httpSecurityHeadersMiddleware from '@middy/http-security-headers' import httpUrlencodeBodyParserMiddleware from '@middy/http-urlencode-body-parser' import httpUrlencodePathParametersParserMiddleware from '@middy/http-urlencode-path-parser' import warmupMiddleware from 'warmup' import { handler as getHandler } from './handlers/get-user.js' import { handler as postHandler } from './handlers/get-user.js' const routes = [ { method: 'GET', path: '/user/{id}', handler: getHandler }, { method: 'POST', path: '/user', handler: postHandler } ] export const handler = middy({ timeoutEarlyResponse: () =&gt; { return { statusCode: 408 } } }) .use(warmupMiddleware()) .use(httpEventNormalizerMiddleware()) .use(httpHeaderNormalizerMiddleware()) .use( httpContentNegotiationMiddleware({ availableLanguages: ['en-CA', 'fr-CA'], availableMediaTypes: ['application/json'] }) ) .use(httpUrlencodePathParametersParserMiddleware()) // Start oneOf .use(httpUrlencodeBodyParserMiddleware()) .use(httpJsonBodyParserMiddleware()) .use(httpMultipartBodyParserMiddleware()) // End oneOf .use(httpSecurityHeadersMiddleware()) .use(httpCorsMiddleware()) .use(httpContentEncodingMiddleware()) .use( httpResponseSerializerMiddleware({ serializers: [ { regex: /^application\\/json$/, serializer: ({ body }) =&gt; JSON.stringify(body) } ], default: 'application/json' }) ) .use(httpPartialResponseMiddleware()) .use(httpErrorHandlerMiddleware()) .handler(httpRouterHandler(routes)) Copy "},{"title":"CloudFormation","type":0,"sectionRef":"#","url":"docs/events/cloud-formation","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"CloudFormation","url":"docs/events/cloud-formation#aws-documentation","content":"Using AWS Lambda with AWS CloudFormation TODO "},{"title":"Example​","type":1,"pageTitle":"CloudFormation","url":"docs/events/cloud-formation#example","content":"import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"CloudFront Lambda@Edge","type":0,"sectionRef":"#","url":"docs/events/cloud-front","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"CloudFront Lambda@Edge","url":"docs/events/cloud-front#aws-documentation","content":"Using AWS Lambda with CloudFront Lambda@Edge TODO "},{"title":"Example​","type":1,"pageTitle":"CloudFront Lambda@Edge","url":"docs/events/cloud-front#example","content":"import middy from '@middy/core' export const handler = middy() //.use(cfHeaderNormalizer()) // Let use know if this would have value .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"Cloud Watch Logs","type":0,"sectionRef":"#","url":"docs/events/cloud-watch-logs","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"Cloud Watch Logs","url":"docs/events/cloud-watch-logs#aws-documentation","content":"Using Lambda with CloudWatch Logs TODO "},{"title":"Example​","type":1,"pageTitle":"Cloud Watch Logs","url":"docs/events/cloud-watch-logs#example","content":"import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"CloudTrail","type":0,"sectionRef":"#","url":"docs/events/cloud-trail","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"CloudTrail","url":"docs/events/cloud-trail#aws-documentation","content":"Using AWS Lambda with AWS CloudTrail TODO "},{"title":"Example​","type":1,"pageTitle":"CloudTrail","url":"docs/events/cloud-trail#example","content":"import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"Code Commit","type":0,"sectionRef":"#","url":"docs/events/code-commit","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"Code Commit","url":"docs/events/code-commit#aws-documentation","content":"Using AWS Lambda with AWS CodeCommit TODO "},{"title":"Example​","type":1,"pageTitle":"Code Commit","url":"docs/events/code-commit#example","content":"import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"Cognito","type":0,"sectionRef":"#","url":"docs/events/cognito","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"Cognito","url":"docs/events/cognito#aws-documentation","content":"Using AWS Lambda with Amazon Cognito TODO "},{"title":"Example​","type":1,"pageTitle":"Cognito","url":"docs/events/cognito#example","content":"import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"CodePipeline","type":0,"sectionRef":"#","url":"docs/events/code-pipeline","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"CodePipeline","url":"docs/events/code-pipeline#aws-documentation","content":"Using AWS Lambda with AWS CodePipeline TODO "},{"title":"Example​","type":1,"pageTitle":"CodePipeline","url":"docs/events/code-pipeline#example","content":"import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"Config","type":0,"sectionRef":"#","url":"docs/events/config","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"Config","url":"docs/events/config#aws-documentation","content":"Using AWS Lambda with AWS Config TODO "},{"title":"Example​","type":1,"pageTitle":"Config","url":"docs/events/config#example","content":"import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"DynamoDB","type":0,"sectionRef":"#","url":"docs/events/dynamodb","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"DynamoDB","url":"docs/events/dynamodb#aws-documentation","content":"Using AWS Lambda with Amazon DynamoDB TODO "},{"title":"Example​","type":1,"pageTitle":"DynamoDB","url":"docs/events/dynamodb#example","content":"import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"Connect","type":0,"sectionRef":"#","url":"docs/events/connect","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"Connect","url":"docs/events/connect#aws-documentation","content":"Using Lambda with Amazon Connect TODO "},{"title":"Example​","type":1,"pageTitle":"Connect","url":"docs/events/connect#example","content":"import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"EC2","type":0,"sectionRef":"#","url":"docs/events/ec2","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"EC2","url":"docs/events/ec2#aws-documentation","content":"Using AWS Lambda with Amazon EC2 TODO "},{"title":"Example​","type":1,"pageTitle":"EC2","url":"docs/events/ec2#example","content":"import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"EventBridge","type":0,"sectionRef":"#","url":"docs/events/event-bridge","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"EventBridge","url":"docs/events/event-bridge#aws-documentation","content":"Using AWS Lambda with Amazon EventBridge (CloudWatch Events) TODO "},{"title":"Example​","type":1,"pageTitle":"EventBridge","url":"docs/events/event-bridge#example","content":"import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"Function URL","type":0,"sectionRef":"#","url":"docs/events/function-url","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"Function URL","url":"docs/events/function-url#aws-documentation","content":"Using AWS Lambda with Amazon API GatewayWorking with HTTP APIs TODO "},{"title":"Example​","type":1,"pageTitle":"Function URL","url":"docs/events/function-url#example","content":"import middy from '@middy/core' import errorLoggerMiddleware from '@middy/error-logger' import inputOutputLoggerMiddleware from '@middy/input-output-logger' import httpContentNegotiationMiddleware from '@middy/http-content-negotiation' import httpContentEncodingMiddleware from '@middy/http-content-encoding' import httpCorsMiddleware from '@middy/http-cors' import httpErrorHandlerMiddleware from '@middy/http-error-handler' import httpEventNormalizerMiddleware from '@middy/http-event-normalizer' import httpHeaderNormalizerMiddleware from '@middy/http-header-normalizer' import httpJsonBodyParserMiddleware from '@middy/http-json-body-parser' import httpMultipartBodyParserMiddleware from '@middy/http-multipart-body-parser' import httpPartialResponseMiddleware from '@middy/http-partial-response' import httpResponseSerializerMiddleware from '@middy/http-response-serializer' import httpSecurityHeadersMiddleware from '@middy/http-security-headers' import httpUrlencodeBodyParserMiddleware from '@middy/http-urlencode-body-parser' import httpUrlencodePathParametersParserMiddleware from '@middy/http-urlencode-path-parser' import validatorMiddleware from 'validator' // or `middy-ajv` import warmupMiddleware from 'warmup' import inputSchema from './eventSchema.json' assert { type: 'json' } import outputSchema from './responseSchema.json' assert { type: 'json' } export const handler = middy({ timeoutEarlyResponse: () =&gt; { return { statusCode: 408 } } }) .use(warmupMiddleware()) .use(httpEventNormalizerMiddleware()) .use(httpHeaderNormalizerMiddleware()) .use( httpContentNegotiationMiddleware({ availableLanguages: ['en-CA', 'fr-CA'], availableMediaTypes: ['application/json'] }) ) .use(httpUrlencodePathParametersParserMiddleware()) // Start oneOf .use(httpUrlencodeBodyParserMiddleware()) .use(httpJsonBodyParserMiddleware()) .use(httpMultipartBodyParserMiddleware()) // End oneOf .use(httpSecurityHeadersMiddleware()) .use(httpCorsMiddleware()) .use(httpContentEncodingMiddleware()) .use( httpResponseSerializerMiddleware({ serializers: [ { regex: /^application\\/json$/, serializer: ({ body }) =&gt; JSON.stringify(body) } ], default: 'application/json' }) ) .use(httpPartialResponseMiddleware()) .use(validatorMiddleware({ inputSchema, outputSchema })) .use(httpErrorHandlerMiddleware()) .handler((event, context, { signal }) =&gt; { // ... }) Copy "},{"title":"All AWS Events","type":0,"sectionRef":"#","url":"docs/events/intro","content":"","keywords":""},{"title":"Middlewares that can benefit any Lambda​","type":1,"pageTitle":"All AWS Events","url":"docs/events/intro#middlewares-that-can-benefit-any-lambda","content":"import middy from '@middy/core' import cloudWatchMetricsMiddleware from '@middy/cloudwatch-metrics' import errorLoggerMiddleware from '@middy/error-logger' import inputOutputLoggerMiddleware from '@middy/input-output-logger' import validatorMiddleware from 'validator' import warmupMiddleware from 'warmup' import inputSchema from './eventSchema.json' assert { type: 'json' } import outputSchema from './responseSchema.json' assert { type: 'json' } const handler = middy() .use(warmupMiddleware()) .use(cloudWatchMetricsMiddleware()) .use(inputOutputLoggerMiddleware()) .use(errorLoggerMiddleware()) .use(validatorMiddleware({ inputSchema, outputSchema })) .handler(async (event, context, { signal }) =&gt; { // ... }) Copy "},{"title":"Need secrets? We have you covered there too​","type":1,"pageTitle":"All AWS Events","url":"docs/events/intro#need-secrets-we-have-you-covered-there-too","content":"import middy from '@middy/core' import { getInternal } from '@middy/util' import rdsSignerMiddleware from '@middy/rds-signer' import secretsManagerMiddleware from '@middy/secrets-manager' import ssmMiddleware from '@middy/ssm' import stsMiddleware from '@middy/sts' export const handler = middy() .use( rdsSignerMiddleware({ fetchData: { rdsSigner: { region: process.env.AWS_REGION, hostname: process.env.RDS_HOSTNAME, username: 'iam_role', database: 'database', port: 5555 } } }) ) .use( secretsManagerMiddleware({ fetchData: { secretsManager: '/dev/service_name/key_name' } }) ) .use( ssmMiddleware({ fetchData: { ssm: '/dev/service_name/key_name' } }) ) .use( stsMiddleware({ fetchData: { sts: { RoleArn: '.../role' } } }) ) .before(async (request) =&gt; { request.context.secrets = await getInternal(true, request) }) .handler(async (event, context, { signal }) =&gt; { // context = { rdsSigner, secretsManager, ssm, sts } }) Copy "},{"title":"Internet of things (IoT)","type":0,"sectionRef":"#","url":"docs/events/iot","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"Internet of things (IoT)","url":"docs/events/iot#aws-documentation","content":"Using AWS Lambda with AWS IoT TODO "},{"title":"Example​","type":1,"pageTitle":"Internet of things (IoT)","url":"docs/events/iot#example","content":"import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"Kafka, Managed Streaming (MSK)","type":0,"sectionRef":"#","url":"docs/events/kafka-managed-streaming","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"Kafka, Managed Streaming (MSK)","url":"docs/events/kafka-managed-streaming#aws-documentation","content":"Using Lambda with Amazon MSK TODO "},{"title":"Example​","type":1,"pageTitle":"Kafka, Managed Streaming (MSK)","url":"docs/events/kafka-managed-streaming#example","content":"import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"Kafka, Self-Managed","type":0,"sectionRef":"#","url":"docs/events/kafka-self-managed","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"Kafka, Self-Managed","url":"docs/events/kafka-self-managed#aws-documentation","content":"Using Lambda with self-managed Apache Kafka TODO "},{"title":"Example​","type":1,"pageTitle":"Kafka, Self-Managed","url":"docs/events/kafka-self-managed#example","content":"import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"Kinesis Firehose","type":0,"sectionRef":"#","url":"docs/events/kinesis-firehose","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"Kinesis Firehose","url":"docs/events/kinesis-firehose#aws-documentation","content":"Using AWS Lambda with Amazon Kinesis Data Firehose TODO "},{"title":"Example​","type":1,"pageTitle":"Kinesis Firehose","url":"docs/events/kinesis-firehose#example","content":"import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"IoT Events","type":0,"sectionRef":"#","url":"docs/events/iot-events","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"IoT Events","url":"docs/events/iot-events#aws-documentation","content":"Using AWS Lambda with AWS IoT Events TODO "},{"title":"Example​","type":1,"pageTitle":"IoT Events","url":"docs/events/iot-events#example","content":"import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"Kinesis Streams","type":0,"sectionRef":"#","url":"docs/events/kinesis-streams","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"Kinesis Streams","url":"docs/events/kinesis-streams#aws-documentation","content":"Using AWS Lambda with Amazon Kinesis TODO "},{"title":"Example​","type":1,"pageTitle":"Kinesis Streams","url":"docs/events/kinesis-streams#example","content":"import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"Lex","type":0,"sectionRef":"#","url":"docs/events/lex","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"Lex","url":"docs/events/lex#aws-documentation","content":"Using AWS Lambda with Amazon LexUsing an AWS Lambda function with Amazon Lex V2 TODO "},{"title":"Example​","type":1,"pageTitle":"Lex","url":"docs/events/lex#example","content":"import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"MQ","type":0,"sectionRef":"#","url":"docs/events/mq","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"MQ","url":"docs/events/mq#aws-documentation","content":"Using Lambda with Amazon MQ TODO "},{"title":"Example​","type":1,"pageTitle":"MQ","url":"docs/events/mq#example","content":"import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"RDS","type":0,"sectionRef":"#","url":"docs/events/rds","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"RDS","url":"docs/events/rds#aws-documentation","content":"Using AWS Lambda with Amazon RDS TODO "},{"title":"Example​","type":1,"pageTitle":"RDS","url":"docs/events/rds#example","content":"import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) // RDS -&gt; SNS -&gt; Lambda .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"S3","type":0,"sectionRef":"#","url":"docs/events/s3","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"S3","url":"docs/events/s3#aws-documentation","content":"Using AWS Lambda with Amazon S3 TODO "},{"title":"Example​","type":1,"pageTitle":"S3","url":"docs/events/s3#example","content":"import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) // S3 -&gt; SNS -&gt; SQS -&gt; Lambda .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"S3 Batch","type":0,"sectionRef":"#","url":"docs/events/s3-batch","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"S3 Batch","url":"docs/events/s3-batch#aws-documentation","content":"Using AWS Lambda with Amazon S3 batch operations TODO "},{"title":"Example​","type":1,"pageTitle":"S3 Batch","url":"docs/events/s3-batch#example","content":"import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"Secrets Manager","type":0,"sectionRef":"#","url":"docs/events/secrets-manager","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"Secrets Manager","url":"docs/events/secrets-manager#aws-documentation","content":"Using AWS Lambda with Secrets Manager TODO "},{"title":"Example​","type":1,"pageTitle":"Secrets Manager","url":"docs/events/secrets-manager#example","content":"import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"S3 Object","type":0,"sectionRef":"#","url":"docs/events/s3-object","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"S3 Object","url":"docs/events/s3-object#aws-documentation","content":"Transforming S3 Objects with S3 Object LambdaTransforming objects with S3 Object Lambda TODO "},{"title":"Example​","type":1,"pageTitle":"S3 Object","url":"docs/events/s3-object#example","content":"import middy from '@middy/core' import s3ObjectResponseMiddleware from '@middy/s3-object-response' import {captureAWSClient, captureHTTPsGlobal} from 'aws-xray-sdk-core' export const handler = middy() .use(s3ObjectResponseMiddleware({ awsClientCapture: captureAWSClient, httpsCapture: captureHTTPsGlobal, bodyType: 'promise' })) .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"SES","type":0,"sectionRef":"#","url":"docs/events/ses","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"SES","url":"docs/events/ses#aws-documentation","content":"Using AWS Lambda with Amazon SES TODO "},{"title":"Example​","type":1,"pageTitle":"SES","url":"docs/events/ses#example","content":"import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"SNS","type":0,"sectionRef":"#","url":"docs/events/sns","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"SNS","url":"docs/events/sns#aws-documentation","content":"Using AWS Lambda with Amazon SNS TODO "},{"title":"Example​","type":1,"pageTitle":"SNS","url":"docs/events/sns#example","content":"import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"SQS","type":0,"sectionRef":"#","url":"docs/events/sqs","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"SQS","url":"docs/events/sqs#aws-documentation","content":"Using AWS Lambda with Amazon SQS TODO "},{"title":"Example​","type":1,"pageTitle":"SQS","url":"docs/events/sqs#example","content":"import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' import sqsPartialBatchFailure from '@middy/sqs-partial-batch-failure' export const handler = middy() .use(eventNormalizerMiddleware()) .use(sqsPartialBatchFailure()) .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"WorkMail","type":0,"sectionRef":"#","url":"docs/events/workmail","content":"","keywords":""},{"title":"AWS Documentation​","type":1,"pageTitle":"WorkMail","url":"docs/events/workmail#aws-documentation","content":"Configuring AWS Lambda for Amazon WorkMail TODO "},{"title":"Example​","type":1,"pageTitle":"WorkMail","url":"docs/events/workmail#example","content":"import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... }) Copy "},{"title":"FAQ","type":0,"sectionRef":"#","url":"docs/faq","content":"","keywords":""},{"title":"My lambda keep timing out without responding, what do I do?​","type":1,"pageTitle":"FAQ","url":"docs/faq#my-lambda-keep-timing-out-without-responding-what-do-i-do","content":"Likely your event loop is not empty. This happens when you have a database connect still open for example. Checkout @middy/do-not-wait-for-empty-event-loop. "},{"title":"Apollo Server","type":0,"sectionRef":"#","url":"docs/integrations/apollo-server","content":"Apollo Server caution This page is a work in progress. If you want to help us to make this page better, please consider contributing on GitHub. import middy from '@middy/core' import { ApolloServer, gql } from 'apollo-server-lambda' import { buildFederatedSchema } from '@apollo/federation' import { resolvers } from './graphql/resolvers.js' import { graphqlFileToStr } from './graphql/schema.js' const graphQL = new ApolloServer({ schema: buildFederatedSchema({ typeDefs: gql(graphqlFileToStr), resolvers }) }) // Do not use: `@middy/http-json-body-parser` it is already handled within apollo export const handler = middy(graphQL.createHandler()) Copy","keywords":""},{"title":"CDK","type":0,"sectionRef":"#","url":"docs/integrations/cdk","content":"CDK caution This page is a work in progress. If you want to help us to make this page better, please consider contributing on GitHub.","keywords":""},{"title":"Integrations","type":0,"sectionRef":"#","url":"docs/integrations/intro","content":"Integrations caution This page is a work in progress. If you want to help us to make this page better, please consider contributing on GitHub.","keywords":""},{"title":"Lambda Powertools","type":0,"sectionRef":"#","url":"docs/integrations/lambda-powertools","content":"Lambda Powertools caution This page is a work in progress. If you want to help us to make this page better, please consider contributing on GitHub.","keywords":""},{"title":"Pino","type":0,"sectionRef":"#","url":"docs/integrations/pino","content":"Pino caution This page is a work in progress. If you want to help us to make this page better, please consider contributing on GitHub.","keywords":""},{"title":"AWS Relational Database Service (RDS)","type":0,"sectionRef":"#","url":"docs/integrations/RDS","content":"AWS Relational Database Service (RDS) caution This page is a work in progress. If you want to help us to make this page better, please consider contributing on GitHub. First, you need to pass in a password. In order from most secure to least: RDS.Signer, SecretsManager, SSM using SecureString.SSM can be considered equally secure to SecretsManager if you have your own password rotation system. Additionally, you will want to verify the RDS certificate and the domain of your connection. You can use this sudo code to get you started: import tls from 'tls' // https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL.html // TODO test pulling from ENV process.env.NODE_EXTRA_CA_CERTS const ca = `-----BEGIN CERTIFICATE----- ...` connectionOptions = { ..., ssl: { rejectUnauthorized: true, ca, checkServerIdentity: (host, cert) =&gt; { const error = tls.checkServerIdentity(host, cert) if ( error &amp;&amp; !cert.subject.CN.endsWith('.rds.amazonaws.com') ) { return error } } } } Copy Corresponding RDS.ParameterGroups values should be set to enforce TLS connections.","keywords":""},{"title":"Serverless Framework","type":0,"sectionRef":"#","url":"docs/integrations/serverless-framework","content":"Serverless Framework caution This page is a work in progress. If you want to help us to make this page better, please consider contributing on GitHub.","keywords":""},{"title":"Serverless Stack","type":0,"sectionRef":"#","url":"docs/integrations/serverless-stack","content":"Serverless Stack caution This page is a work in progress. If you want to help us to make this page better, please consider contributing on GitHub.","keywords":""},{"title":"Terraform","type":0,"sectionRef":"#","url":"docs/integrations/terraform","content":"Terraform caution This page is a work in progress. If you want to help us to make this page better, please consider contributing on GitHub.","keywords":""},{"title":"Contributing","type":0,"sectionRef":"#","url":"docs/intro/contributing","content":"Contributing In the spirit of Open Source Software, everyone is very welcome to contribute to this repository. Feel free to raise issues or to submit Pull Requests. Before contributing to the project, make sure to have a look at our Code of Conduct.","keywords":""},{"title":"Getting started","type":0,"sectionRef":"#","url":"docs/intro/getting-started","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"Getting started","url":"docs/intro/getting-started#install","content":"To install middy, you can use NPM: npmYarn npm install --save @middy/core Copy If you are using TypeScript, you will also want to make sure that you have installed the @types/aws-lambda peer-dependency: npmYarn npm install --save-dev @types/aws-lambda Copy "},{"title":"Usage​","type":1,"pageTitle":"Getting started","url":"docs/intro/getting-started#usage","content":"As you will see in the next example, using middy is very simple and requires just few steps: Write your Lambda handlers as usual, focusing mostly on implementing the bare business logic for them.Import middy and all the middlewares you want to use.Wrap your handler in the middy() factory function. This will return a new enhanced instance of your original handler, to which you will be able to attach the middlewares you need.Attach all the middlewares you need using the function .use(somemiddleware()) "},{"title":"Example​","type":1,"pageTitle":"Getting started","url":"docs/intro/getting-started#example","content":"import middy from '@middy/core' import middleware1 from 'sample-middleware1' import middleware2 from 'sample-middleware2' import middleware3 from 'sample-middleware3' const baseHandler = (event, context) =&gt; { /* your business logic */ } const handler = middy(baseHandler) handler .use(middleware1()) .use(middleware2()) .use(middleware3()) module.exports = { handler } Copy .use() takes a single middleware or an array of middlewares, so you can attach multiple middlewares in a single call: import middy from &quot;@middy/core&quot;; import middleware1 from &quot;sample-middleware1&quot;; import middleware2 from &quot;sample-middleware2&quot;; import middleware3 from &quot;sample-middleware3&quot;; const middlewares = [middleware1(), middleware2(), middleware3()] const baseHandler = (event, context) =&gt; { /* your business logic */ }; const handler = middy(baseHandler); handler.use(middlewares) module.exports = { handler }; Copy You can also attach inline middlewares by using the functions .before, .after and .onError. For a more detailed use case and examples check the Writing a middleware section. "},{"title":"Early return","type":0,"sectionRef":"#","url":"docs/intro/early-interrupt","content":"Early return Some middlewares might need to stop the whole execution flow and return a response immediately. If you want to do this you can invoke return response in your middleware. Note: this will totally stop the execution of successive middlewares in any phase (before, after, onError) and returns an early response (or an error) directly at the Lambda level. If your middlewares do a specific task on every request like output serialization or error handling, these won't be invoked in this case. In this example, we can use this capability for building a sample caching middleware: // some function that calculates the cache id based on the current event const calculateCacheId = event =&gt; { /* ... */ } const storage = {} // middleware const cacheMiddleware = options =&gt; { let cacheKey const cacheMiddlewareBefore = async (request) =&gt; { cacheKey = options.calculateCacheId(request.event) if (options.storage.hasOwnProperty(cacheKey)) { // exits early and returns the value from the cache if it's already there return options.storage[cacheKey] } } const cacheMiddlewareAfter = async (request) =&gt; { // stores the calculated response in the cache options.storage[cacheKey] = request.response } return { before: cacheMiddlewareBefore, after: cacheMiddlewareAfter } } // sample usage const handler = middy((event, context) =&gt; { /* ... */ }).use( cacheMiddleware({ calculateCacheId, storage }) ) Copy","keywords":""},{"title":"History","type":0,"sectionRef":"#","url":"docs/intro/history","content":"","keywords":""},{"title":"A brief history of Middy​","type":1,"pageTitle":"History","url":"docs/intro/history#a-brief-history-of-middy","content":"Middy was started in the early days of AWS Lambda (~2016) and it was initially only used to remove duplication in a big serverless project with tons of lambdas. Only in August 2017 Middy's source code was released on GitHub making it an open source project.2017-08-03: First commit2017-09-04: v0.2.1 First release2018-05-20: v1.0.0-alpha2020-01-09: v1.0.0-beta2020-04-25: v1.0.0 Released2020 Review by @lmammino2020 Review by @willfarrell2021: v2.0.0 Coming soon2021-01-24: v2.0.0-alpha2021-03-12: v2.0.0-beta2021-04-01: v2.0.02021-02-02: 2021 Review from @lmammino Fun Fact: The adding of the emoji-icon was the 2nd commit to the project. "},{"title":"Handling Errors","type":0,"sectionRef":"#","url":"docs/intro/handling-errors","content":"Handling Errors But, what happens when there is an error? When there is an error, the regular control flow is stopped and the execution is moved back to all the middlewares that implemented a special phase called onError, following the order they have been attached. Every onError middleware can decide to handle the error and create a proper response or to delegate the error to the next middleware. When a middleware handles the error and creates a response, the execution is still propagated to all the other error middlewares and they have a chance to update or replace the response as needed. At the end of the error middlewares sequence, the response is returned to the user. If no middleware manages the error, the Lambda execution fails reporting the unmanaged error. // Initialize response request.response = request.response ?? {} // Add to response request.response.add = 'more' // Override an error request.error = new Error('...') // handle the error return request.response Copy","keywords":""},{"title":"How it works","type":0,"sectionRef":"#","url":"docs/intro/how-it-works","content":"","keywords":""},{"title":"Execution order​","type":1,"pageTitle":"How it works","url":"docs/intro/how-it-works#execution-order","content":"Middlewares have two phases: before and after. The before phase, happens before the handler is executed. In this code the response is not created yet, so you will have access only to the request. The after phase, happens after the handler is executed. In this code you will have access to both the request and the response. If you have three middlewares attached (as in the image above), this is the expected order of execution: middleware1 (before)middleware2 (before)middleware3 (before)handlermiddleware3 (after)middleware2 (after)middleware1 (after) Notice that in the after phase, middlewares are executed in inverted order, this way the first handler attached is the one with the highest priority as it will be the first able to change the request and last able to modify the response before it gets sent to the user. "},{"title":"Influence","type":0,"sectionRef":"#","url":"docs/intro/influence","content":"Influence Middy has been one of the first projects to encourage the adoption of middlewares to simplify code reuse and best practices within the context of Lambda. Since middy started to gain popularity in the Node.js ecosystem, we have seen some independent projects taking the same ideas to other ecosystems: .Net port Voxel.MiddyNet @vgaltesGoLang port Vesper Do you have a similar project? Let us know.","keywords":""},{"title":"Plugins","type":0,"sectionRef":"#","url":"docs/intro/plugins","content":"Plugins caution This page is a work in progress. If you want to help us to make this page better, please consider contributing on GitHub.","keywords":""},{"title":"Release Cycle","type":0,"sectionRef":"#","url":"docs/intro/release-cycle","content":"Release Cycle Each major release has a two (2) month alpha period, one (1) month beta, before a full release in April. Each release goes into maintenance after nine (9) months, as the next release enters alpha. This time period is choosen for alignment with AWS Lambda nodejs runtime releases. All Node.js Long-Term Support (LTS) releases that have AWS Lambda runtimes are supported. Version\tStatus\tAlpha Release\tStable Release\tEnd-of-Lifev0\tDeprecated\t2017-08-03\t2017-09-04\t2020-04-25 v1\tDeprecated\t2018-05-20\t2020-04-25\t2021-04-01 v2\tMaintenance\t2021-01-24\t2021-04-01\t2022-04-01 v3\tAlpha\t2022-01-04\t2022-04-01\t2023-04-01 v4\tPending\t2023-01-01\t2023-04-01\t2024-04-01 Dates are subject to change. If your organization requires a longer maintenance period of Middy, please reach out.","keywords":""},{"title":"Use with TypeScript","type":0,"sectionRef":"#","url":"docs/intro/typescript","content":"Use with TypeScript Middy can be used with TypeScript with typings built in in every official package. Here's an example of how you might be using Middy with TypeScript for a Lambda receiving events from API Gateway: import middy from '@middy/core' import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda' async function baseHandler (event: APIGatewayProxyEvent): Promise&lt;APIGatewayProxyResult&gt; { // the returned response will be checked against the type `APIGatewayProxyResult` return { statusCode: 200, body: `Hello from ${event.path}` } } let handler = middy(baseHandler) handler .use(someMiddleware) .use(someOtherMiddleware) export default handler Copy You can also write custom middlewares with TypeScript.","keywords":""},{"title":"Utilities","type":0,"sectionRef":"#","url":"docs/intro/utilities","content":"Utilities caution This page is a work in progress. If you want to help us to make this page better, please consider contributing on GitHub.","keywords":""},{"title":"cloudwatch-metrics","type":0,"sectionRef":"#","url":"docs/middlewares/cloudwatch-metrics","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"cloudwatch-metrics","url":"docs/middlewares/cloudwatch-metrics#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/cloudwatch-metrics Copy "},{"title":"Options​","type":1,"pageTitle":"cloudwatch-metrics","url":"docs/middlewares/cloudwatch-metrics#options","content":"namespace (string) (optional): Defaults to aws-embedded-metrics. Sets the CloudWatch namespace that extracted metrics should be published to.dimensions (Record&lt;String, String&gt;[]) (optional): Defaults to [ {&quot;ServiceName&quot;: &quot;myLambdaFunctionName&quot;}, {&quot;ServiceType&quot;: &quot;AWS::Lambda::Function&quot;}, {&quot;LogGroupName&quot;: &quot;logGroupNameUsedByMyLambda&quot;}, ] Copy Explicitly override all dimensions. This will remove the default dimensions. You can provide an empty array to record all metrics without dimensions. "},{"title":"Sample usage​","type":1,"pageTitle":"cloudwatch-metrics","url":"docs/middlewares/cloudwatch-metrics#sample-usage","content":"const middy = require('@middy/core') const cloudwatchMetrics = require('@middy/cloudwatch-metrics') const handler = middy((event, context) =&gt; { context.metrics.putMetric(&quot;ProcessingLatency&quot;, 100, &quot;Milliseconds&quot;); context.metrics.setProperty(&quot;RequestId&quot;, &quot;422b1569-16f6-4a03-b8f0-fe3fd9b100f8&quot;) }) handler.use(cloudwatchMetrics({ namspace: &quot;myAppliction&quot;, dimensions: [ { &quot;Action&quot;: &quot;Buy&quot; } ] })) Copy "},{"title":"do-not-wait-for-empty-event-loop","type":0,"sectionRef":"#","url":"docs/middlewares/do-not-wait-for-empty-event-loop","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"do-not-wait-for-empty-event-loop","url":"docs/middlewares/do-not-wait-for-empty-event-loop#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/do-not-wait-for-empty-event-loop Copy "},{"title":"Options​","type":1,"pageTitle":"do-not-wait-for-empty-event-loop","url":"docs/middlewares/do-not-wait-for-empty-event-loop#options","content":"By default the middleware sets the callbackWaitsForEmptyEventLoop property to false only in the before phase, meaning you can override it in handler to true if needed. You can set it in all steps with the options: runOnBefore (defaults to true) - sets property before running your handlerrunOnAfter (defaults to false)runOnError (defaults to false) "},{"title":"Sample usage​","type":1,"pageTitle":"do-not-wait-for-empty-event-loop","url":"docs/middlewares/do-not-wait-for-empty-event-loop#sample-usage","content":"import middy from '@middy/core' import doNotWaitForEmptyEventLoop from '@middy/do-not-wait-for-empty-event-loop' const handler = middy((event, context) =&gt; { return {} }) handler.use(doNotWaitForEmptyEventLoop({runOnError: true})) // When Lambda runs the handler it gets context with // callbackWaitsForEmptyEventLoop property set to false handler(event, context, (_, response) =&gt; { t.is(context.callbackWaitsForEmptyEventLoop,false) }) Copy "},{"title":"error-logger","type":0,"sectionRef":"#","url":"docs/middlewares/error-logger","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"error-logger","url":"docs/middlewares/error-logger#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/error-logger Copy "},{"title":"Options​","type":1,"pageTitle":"error-logger","url":"docs/middlewares/error-logger#options","content":"logger property: a function (default console.error) that is used to define the logging logic. It receives the Error object as first and only parameter. "},{"title":"Sample usage​","type":1,"pageTitle":"error-logger","url":"docs/middlewares/error-logger#sample-usage","content":"import middy from '@middy/core' import errorLogger from '@middy/error-logger' const handler = middy((event, context) =&gt; { // your handler logic }) handler .use(errorLogger()) Copy "},{"title":"event-normalizer","type":0,"sectionRef":"#","url":"docs/middlewares/event-normalizer","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"event-normalizer","url":"docs/middlewares/event-normalizer#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/event-normalizer Copy "},{"title":"Sample usage​","type":1,"pageTitle":"event-normalizer","url":"docs/middlewares/event-normalizer#sample-usage","content":"import middy from '@middy/core' import eventNormalizer from '@middy/event-normalizer' const lambdaHandler = (event, context) =&gt; { const { Records } = event for(const record of Records) { // ... } } const handler = middy(lambdaHandler).use(eventNormalizer()) Copy "},{"title":"http-content-encoding","type":0,"sectionRef":"#","url":"docs/middlewares/http-content-encoding","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"http-content-encoding","url":"docs/middlewares/http-content-encoding#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/http-content-encoding Copy "},{"title":"Options​","type":1,"pageTitle":"http-content-encoding","url":"docs/middlewares/http-content-encoding#options","content":"br (object) (default {}): zlib.createBrotliCompress brotliOptionsgzip (object) (default {}): zlib.createGzip gzipOptionsdeflate (object) (default {}): zlib.createDeflate deflateOptionsoverridePreferredEncoding (array[string]) (optional): Override the preferred encoding order, most browsers prefer gzip over br, even though br has higher compression. Default: [] NOTES: Important For br encoding NodeJS defaults to 11. Levels 10 &amp; 11 have been shown to have lower performance for the level of compression they apply. Testing is recommended to ensure the right balance of compression &amp; performance. "},{"title":"Sample usage​","type":1,"pageTitle":"http-content-encoding","url":"docs/middlewares/http-content-encoding#sample-usage","content":"import middy from '@middy/core' import httpContentNegotiation from '@middy/http-content-negotiation' import httpContentEncoding from '@middy/http-content-encoding' import { constants } from 'zlib' const handler = middy((event, context) =&gt; { return { statusCode: 200, body: '{...}' } }) handler .use(httpContentNegotiation()) .use(httpCompressMiddleware({ br: { params: { [constants.BROTLI_PARAM_MODE]: constants.BROTLI_MODE_TEXT, // adjusted for UTF-8 text [constants.BROTLI_PARAM_QUALITY]: 7 } }, overridePreferredEncoding: ['br', 'gzip', 'deflate'] })) export default { handler } Copy "},{"title":"http-content-negotiation","type":0,"sectionRef":"#","url":"docs/middlewares/http-content-negotiation","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"http-content-negotiation","url":"docs/middlewares/http-content-negotiation#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/http-content-negotiation Copy "},{"title":"Options​","type":1,"pageTitle":"http-content-negotiation","url":"docs/middlewares/http-content-negotiation#options","content":"parseCharsets (defaults to true) - Allows enabling/disabling the charsets parsingavailableCharsets (defaults to undefined) - Allows defining the list of charsets supported by the Lambda functionparseEncodings (defaults to true) - Allows enabling/disabling the encodings parsingavailableEncodings (defaults to undefined) - Allows defining the list of encodings supported by the Lambda functionparseLanguages (defaults to true) - Allows enabling/disabling the languages parsingavailableLanguages (defaults to undefined) - Allows defining the list of languages supported by the Lambda functionparseMediaTypes (defaults to true) - Allows enabling/disabling the media types parsingavailableMediaTypes (defaults to undefined) - Allows defining the list of media types supported by the Lambda functionfailOnMismatch (defaults to true) - If set to true it will throw an HTTP NotAcceptable (406) exception when the negotiation fails for one of the headers (e.g. none of the languages requested are supported by the app) "},{"title":"Sample usage​","type":1,"pageTitle":"http-content-negotiation","url":"docs/middlewares/http-content-negotiation#sample-usage","content":"import middy from '@middy/core' import httpContentNegotiation from '@middy/http-content-negotiation' import httpHeaderNormalizer from '@middy/http-header-normalizer' import httpErrorHandler from '@middy/http-error-handler' const handler = middy((event, context) =&gt; { let message, body switch (event.preferredLanguage) { case 'it-it': message = 'Ciao Mondo' break case 'fr-fr': message = 'Bonjour le monde' break default: message = 'Hello world' } switch (event.preferredMediaType) { case 'application/xml': body = `&lt;message&gt;${message}&lt;/message&gt;` break case 'application/yaml': body = `---\\nmessage: ${message}` break case 'application/json': body = JSON.stringify({ message }) break default: body = message } return { statusCode: 200, body } }) handler .use(httpHeaderNormalizer()) .use(httpContentNegotiation({ parseCharsets: false, parseEncodings: false, availableLanguages: ['it-it', 'fr-fr', 'en'], availableMediaTypes: ['application/xml', 'application/yaml', 'application/json', 'text/plain'] })) .use(httpErrorHandler()) module.exports = { handler } Copy "},{"title":"http-cors","type":0,"sectionRef":"#","url":"docs/middlewares/http-cors","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"http-cors","url":"docs/middlewares/http-cors#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/http-cors Copy "},{"title":"Options​","type":1,"pageTitle":"http-cors","url":"docs/middlewares/http-cors#options","content":"credentials (bool) (optional): if true, sets Access-Control-Allow-Credentials (default false)headers (string) (optional): value to put in Access-Control-Allow-Headers (default: false)methods (string) (optional): value to put in Access-Control-Allow-Methods (default: false)getOrigin (function(incomingOrigin:string, options)) (optional): take full control of the generating the returned origin. Defaults to using the origin or origins option.origin (string) (optional): origin to put in the header (default: &quot;*&quot;)origins (array) (optional): An array of allowed origins. The incoming origin is matched against the list and is returned if present. exposeHeaders (string) (optional): value to put in Access-Control-Expose-Headers (default: false)maxAge (string) (optional): value to put in Access-Control-Max-Age header (default: null)requestHeaders (string) (optional): value to put in Access-Control-Request-Headers (default: false)requestMethods (string) (optional): value to put in Access-Control-Request-Methods (default: false)cacheControl (string) (optional): value to put in Cache-Control header on pre-flight (OPTIONS) requests (default: null) import middy from '@middy/core' import httpErrorHandler from '@middy/http-error-handler' import cors from '@middy/http-cors' const handler = middy((event, context) =&gt; { throw new createError.UnprocessableEntity() }) handler.use(httpErrorHandler()) .use(cors()) // when Lambda runs the handler... handler({}, {}, (_, response) =&gt; { t.is(response.headers['Access-Control-Allow-Origin'],'*') t.deepEqual(response,{ statusCode: 422, body: 'Unprocessable Entity' }) }) Copy "},{"title":"Sample usage​","type":1,"pageTitle":"http-cors","url":"docs/middlewares/http-cors#sample-usage","content":"import middy from '@middy/core' import cors from '@middy/http-cors' const handler = middy((event, context) =&gt; { return {} }) handler.use(cors()) // when Lambda runs the handler... handler({}, {}, (_, response) =&gt; { t.is(response.headers['Access-Control-Allow-Origin'],'*') }) Copy "},{"title":"http-event-normalizer","type":0,"sectionRef":"#","url":"docs/middlewares/http-event-normalizer","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"http-event-normalizer","url":"docs/middlewares/http-event-normalizer#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/http-event-normalizer Copy "},{"title":"Options​","type":1,"pageTitle":"http-event-normalizer","url":"docs/middlewares/http-event-normalizer#options","content":"payloadFormatVersion (number) (optional): Defaults to 1 . Set it to 2 to use API Gateway HTTP API v2.0 event payload (https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html). "},{"title":"Sample usage​","type":1,"pageTitle":"http-event-normalizer","url":"docs/middlewares/http-event-normalizer#sample-usage","content":"import middy from '@middy/core' import httpEventNormalizer from '@middy/http-event-normalizer' const handler = middy((event, context) =&gt; { console.log(`Hello user ${event.pathParameters.userId}`) // might produce `Hello user undefined`, but not an error return {} }) handler.use(httpEventNormalizer()) Copy "},{"title":"http-error-handler","type":0,"sectionRef":"#","url":"docs/middlewares/http-error-handler","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"http-error-handler","url":"docs/middlewares/http-error-handler#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/http-error-handler Copy "},{"title":"Options​","type":1,"pageTitle":"http-error-handler","url":"docs/middlewares/http-error-handler#options","content":"logger (defaults to console.error) - a logging function that is invoked with the current error as an argument. You can pass false if you don't want the logging to happen.fallbackMessage (default to null) - When non-http errors occur you can catch them by setting a fallback message to be used. These will be returned with a 500 status code. "},{"title":"Sample usage​","type":1,"pageTitle":"http-error-handler","url":"docs/middlewares/http-error-handler#sample-usage","content":"import middy from '@middy/core' import httpErrorHandler from '@middy/http-error-handler' const handler = middy((event, context) =&gt; { throw new createError.UnprocessableEntity() }) handler .use(httpErrorHandler()) // when Lambda runs the handler... handler({}, {}, (_, response) =&gt; { t.deepEqual(response,{ statusCode: 422, body: 'Unprocessable Entity' }) }) Copy "},{"title":"http-header-normalizer","type":0,"sectionRef":"#","url":"docs/middlewares/http-header-normalizer","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"http-header-normalizer","url":"docs/middlewares/http-header-normalizer#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/http-header-normalizer Copy "},{"title":"Options​","type":1,"pageTitle":"http-header-normalizer","url":"docs/middlewares/http-header-normalizer#options","content":"normalizeHeaderKey (function) (optional): a function that accepts an header name as a parameter and returns its canonical representation.canonical (bool) (optional): if true, modifies the headers to canonical format, otherwise the headers are normalized to lowercase (default false) "},{"title":"Sample usage​","type":1,"pageTitle":"http-header-normalizer","url":"docs/middlewares/http-header-normalizer#sample-usage","content":"import middy from '@middy/core' import httpHeaderNormalizer from '@middy/http-header-normalizer' const handler = middy((event, context) =&gt; { return {} }) handler .use(httpHeaderNormalizer()) Copy "},{"title":"http-json-body-parser","type":0,"sectionRef":"#","url":"docs/middlewares/http-json-body-parser","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"http-json-body-parser","url":"docs/middlewares/http-json-body-parser#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/http-json-body-parser Copy "},{"title":"Options​","type":1,"pageTitle":"http-json-body-parser","url":"docs/middlewares/http-json-body-parser#options","content":"reviver (function) (optional): A reviver parameter may be passed which will be used JSON.parseing the body. "},{"title":"Sample usage​","type":1,"pageTitle":"http-json-body-parser","url":"docs/middlewares/http-json-body-parser#sample-usage","content":"import middy from '@middy/core' import httpHeaderNormalizer from '@middy/http-header-normalizer' import httpJsonBodyParser from '@middy/http-json-body-parser' const handler = middy((event, context) =&gt; { return {} }) handler .use(httpHeaderNormalizer()) .use(httpJsonBodyParser()) // invokes the handler const event = { headers: { 'Content-Type': 'application/json' // It is important that the request has the proper content type. }, body: JSON.stringify({foo: 'bar'}) } handler(event, {}, (_, body) =&gt; { t.is(body,{foo: 'bar'}) }) Copy "},{"title":"http-multipart-body-parser","type":0,"sectionRef":"#","url":"docs/middlewares/http-multipart-body-parser","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"http-multipart-body-parser","url":"docs/middlewares/http-multipart-body-parser#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/http-multipart-body-parser Copy "},{"title":"Options​","type":1,"pageTitle":"http-multipart-body-parser","url":"docs/middlewares/http-multipart-body-parser#options","content":"busboy (object) (optional): defaults to {} and it can be used to pass extraparameters to the internal busboy instance at creation time. Checkout the official documentation for more information on the supported options. Note: this middleware will buffer all the data as it is processed internally by busboy, so, if you are using this approach to parse significantly big volumes of data, keep in mind that all the data will be allocated in memory. This is somewhat inevitable with Lambdas (as the data is already encoded into the JSON in memory as Base64), but it's good to keep this in mind and evaluate the impact on you application. If you really have to deal with big files, then you might also want to consider to allowing your users to directly upload files to S3 "},{"title":"Sample usage​","type":1,"pageTitle":"http-multipart-body-parser","url":"docs/middlewares/http-multipart-body-parser#sample-usage","content":"import middy from '@middy/core' import httpHeaderNormalizer from '@middy/http-header-normalizer' import httpMultipartBodyParser from '@middy/http-multipart-body-parser' const handler = middy((event, context) =&gt; { return {} }) handler .use(httpHeaderNormalizer()) .use(httpMultipartBodyParser()) // invokes the handler const event = { headers: { 'Content-Type': 'multipart/form-data; boundary=----WebKitFormBoundaryppsQEwf2BVJeCe0M' }, body: 'LS0tLS0tV2ViS2l0Rm9ybUJvdW5kYXJ5cHBzUUV3ZjJCVkplQ2UwTQ0KQ29udGVudC1EaXNwb3NpdGlvbjogZm9ybS1kYXRhOyBuYW1lPSJmb28iDQoNCmJhcg0KLS0tLS0tV2ViS2l0Rm9ybUJvdW5kYXJ5cHBzUUV3ZjJCVkplQ2UwTS0t', isBase64Encoded: true } handler(event, {}, (_, body) =&gt; { t.is(body,{ foo: 'bar' }) }) Copy "},{"title":"http-response-serializer","type":0,"sectionRef":"#","url":"docs/middlewares/http-response-serializer","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"http-response-serializer","url":"docs/middlewares/http-response-serializer#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/http-response-serializer Copy "},{"title":"Configuration​","type":1,"pageTitle":"http-response-serializer","url":"docs/middlewares/http-response-serializer#configuration","content":"The middleware is configured by defining some serializers. { serializers: [ { regex: /^application\\/xml$/, serializer: ({ body }) =&gt; `&lt;message&gt;${body}&lt;/message&gt;`, }, { regex: /^application\\/json$/, serializer: ({ body }) =&gt; JSON.stringify(body) }, { regex: /^text\\/plain$/, serializer: ({ body }) =&gt; body } ], default: 'application/json' } Copy The default (optional) option is used if the request and handler don't specify what type is wanted. "},{"title":"Serializer Functions​","type":1,"pageTitle":"http-response-serializer","url":"docs/middlewares/http-response-serializer#serializer-functions","content":"When a matching serializer is found, the Content-Type header is set and the serializer function is run. The function is passed the entire response object, and should return either a string or an object. If a string is returned, the body attribute of the response is updated. If an object with a body attribute is returned, the entire response object is replaced. This is useful if you want to manipulate headers or add additional attributes in the Lambda response. "},{"title":"Content Type Negotiation​","type":1,"pageTitle":"http-response-serializer","url":"docs/middlewares/http-response-serializer#content-type-negotiation","content":"The header is not the only way the middleware decides which serializer to execute. The content type is determined in the following order: event.requiredContentType -- allows the handler to override everything elseThe Accept header via acceptevent.preferredContentType -- allows the handler to override the default, but lets the request ask firstdefault middleware configuration All options allow for multiple types to be specified in your order of preference, and the first matching serializer will be executed. "},{"title":"Sample usage​","type":1,"pageTitle":"http-response-serializer","url":"docs/middlewares/http-response-serializer#sample-usage","content":"import middy from '@middy/core' import httpResponseSerializer from '@middy/http-response-serializer' const handler = middy((event, context) =&gt; { const body = 'Hello World' return { statusCode: 200, body } }) handler .use(httpResponseSerializer({ serializers: [ { regex: /^application\\/xml$/, serializer: ({ body }) =&gt; `&lt;message&gt;${body}&lt;/message&gt;`, }, { regex: /^application\\/json$/, serializer: ({ body }) =&gt; JSON.stringify(body) }, { regex: /^text\\/plain$/, serializer: ({ body }) =&gt; body } ], default: 'application/json' })) const event = { headers: { 'Accept': 'application/xml;q=0.9, text/x-dvi; q=0.8, text/x-c' } } handler(event, {}, (_, response) =&gt; { t.is(response.body,'&lt;message&gt;Hello World&lt;/message&gt;') }) Copy "},{"title":"http-security-headers","type":0,"sectionRef":"#","url":"docs/middlewares/http-security-headers","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"http-security-headers","url":"docs/middlewares/http-security-headers#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/http-security-headers Copy "},{"title":"Options​","type":1,"pageTitle":"http-security-headers","url":"docs/middlewares/http-security-headers#options","content":"dnsPrefetchControl controls browser DNS prefetchingexpectCt for handling Certificate Transparency (Future Feature)frameguard to prevent clickjackinghidePoweredBy to remove the Server/X-Powered-By headerhsts for HTTP Strict Transport SecurityieNoOpen sets X-Download-Options for IE8+noSniff to keep clients from sniffing the MIME typereferrerPolicy to hide the Referer headerxssFilter adds some small XSS protections "},{"title":"Sample usage​","type":1,"pageTitle":"http-security-headers","url":"docs/middlewares/http-security-headers#sample-usage","content":"import middy from '@middy/core' import httpSecurityHeaders from '@middy/http-security-headers' const handler = middy((event, context) =&gt; { return {} }) handler .use(httpSecurityHeaders()) Copy "},{"title":"http-partial-response","type":0,"sectionRef":"#","url":"docs/middlewares/http-partial-response","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"http-partial-response","url":"docs/middlewares/http-partial-response#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/http-partial-response Copy "},{"title":"Options​","type":1,"pageTitle":"http-partial-response","url":"docs/middlewares/http-partial-response#options","content":"This middleware does not have any option "},{"title":"Sample usage​","type":1,"pageTitle":"http-partial-response","url":"docs/middlewares/http-partial-response#sample-usage","content":"import middy from '@middy/core' import httpPartialResponse from '@middy/http-partial-response' const handler = middy((event, context) =&gt; { const response = { statusCode: 200, body: { firstname: 'John', lastname: 'Doe', gender: 'male', age: 30, address: { street: 'Avenue des Champs-Élysées', city: 'Paris' } } } return response }) handler.use(httpPartialResponse()) const event = { queryStringParameters: { fields: 'firstname,lastname' } } handler(event, {}, (_, response) =&gt; { expect(response.body).toEqual({ firstname: 'John', lastname: 'Doe' }) }) Copy "},{"title":"http-urlencode-body-parser","type":0,"sectionRef":"#","url":"docs/middlewares/http-urlencode-body-parser","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"http-urlencode-body-parser","url":"docs/middlewares/http-urlencode-body-parser#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/http-urlencode-body-parser Copy "},{"title":"Sample usage​","type":1,"pageTitle":"http-urlencode-body-parser","url":"docs/middlewares/http-urlencode-body-parser#sample-usage","content":"import middy from '@middy/core' import httpHeaderNormalizer from '@middy/http-header-normalizer' import httpUrlEncodeBodyParser from '@middy/http-urlencode-body-parser' const handler = middy((event, context) =&gt; { return event.body // propagates the body as response }) handler .use(httpHeaderNormalizer()) .use(httpUrlEncodeBodyParser()) // When Lambda runs the handler with a sample event... const event = { headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: 'frappucino=muffin&amp;goat%5B%5D=scone&amp;pond=moose' } handler(event, {}, (_, body) =&gt; { t.deepEqual(body, { frappucino: 'muffin', 'goat[]': 'scone', pond: 'moose' }) }) Copy "},{"title":"input-output-logger","type":0,"sectionRef":"#","url":"docs/middlewares/input-output-logger","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"input-output-logger","url":"docs/middlewares/input-output-logger#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/input-output-logger Copy "},{"title":"Options​","type":1,"pageTitle":"input-output-logger","url":"docs/middlewares/input-output-logger#options","content":"logger function (default console.log): logging function that accepts an objectawsContext boolean (default false): Include AWS Lambda context object to the loggeromitPaths string[] (default []): property accepts an array of paths that will be used to remove particular fields import the logged objects. This could serve as a simple way to redact sensitive data from logs (default []). "},{"title":"Sample usage​","type":1,"pageTitle":"input-output-logger","url":"docs/middlewares/input-output-logger#sample-usage","content":"import middy from '@middy/core' import inputOutputLogger from '@middy/input-output-logger' const handler = middy((event, context) =&gt; { const response = { statusCode: 200, headers: {}, body: JSON.stringify({ message: 'hello world' }) }; return response }) handler .use(inputOutputLogger()) Copy import middy from '@middy/core' import inputOutputLogger from '@middy/input-output-logger' import pino from 'pino' const logger = pino() const handler = middy((event, context) =&gt; { // ... return response }) handler .use(inputOutputLogger({ logger: (request) =&gt; { const child = logger.child(request.context) child.info(request.event ?? request.response) }, awsContext: true })) Copy "},{"title":"Official middlewares","type":0,"sectionRef":"#","url":"docs/middlewares/intro","content":"","keywords":""},{"title":"Misc​","type":1,"pageTitle":"Official middlewares","url":"docs/middlewares/intro#misc","content":"error-logger: Logs errorsinput-output-logger: Logs request and responsedo-not-wait-for-empty-event-loop: Sets callbackWaitsForEmptyEventLoop property to falsecloudwatch-metrics: Hydrates lambda's context.metrics property with an instance of AWS MetricLoggerwarmup: Used to pre-warm a lambda function "},{"title":"Request Transformation​","type":1,"pageTitle":"Official middlewares","url":"docs/middlewares/intro#request-transformation","content":"http-content-negotiation: Parses Accept-* headers and provides utilities for content negotiation (charset, encoding, language and media type) for HTTP requestshttp-header-normalizer: Normalizes HTTP header names to their canonical formathttp-json-body-parser: Automatically parses HTTP requests with JSON body and converts the body into an object. Also handles gracefully broken JSON if used in combination ofhttpErrorHandler.http-multipart-body-parser: Automatically parses HTTP requests with content type multipart/form-data and converts the body into an object.http-urlencode-body-parser: Automatically parses HTTP requests with URL encoded body (typically the result of a form submit).http-urlencode-path-parser: Automatically parses HTTP requests with URL encoded path.s3-key-normalizer: Normalizes key names in s3 events.sqs-json-body-parser: Parse body from SQS eventsvalidator: Automatically validates incoming events and outgoing responses against custom schemas "},{"title":"Response Transformation​","type":1,"pageTitle":"Official middlewares","url":"docs/middlewares/intro#response-transformation","content":"http-cors: Sets HTTP CORS headers on responsehttp-error-handler: Creates a proper HTTP response for errors that are created with the http-errors module and represents proper HTTP errors.http-event-normalizer: Normalizes HTTP events by adding an empty object for queryStringParameters, multiValueQueryStringParameters or pathParameters if they are missing.http-security-headers: Applies best practice security headers to responses. It's a simplified port of HelmetJS.http-partial-response: Filter response objects attributes based on query string parameters.http-response-serializer: HTTP response serializer.sqs-partial-batch-failure: handles partially failed SQS batches. "},{"title":"Fetch Data​","type":1,"pageTitle":"Official middlewares","url":"docs/middlewares/intro#fetch-data","content":"rds-signer: Fetches token for connecting to RDS with IAM users.s3-object-response: Gets and write S3 object response.secrets-manager: Fetches parameters from AWS Secrets Manager.ssm: Fetches parameters from AWS Systems Manager Parameter Store.sts: Fetches credentials to assumes IAM roles for connection to other AWS services. "},{"title":"http-urlencode-path-parser","type":0,"sectionRef":"#","url":"docs/middlewares/http-urlencode-path-parser","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"http-urlencode-path-parser","url":"docs/middlewares/http-urlencode-path-parser#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/http-urlencode-path-parser Copy "},{"title":"Options​","type":1,"pageTitle":"http-urlencode-path-parser","url":"docs/middlewares/http-urlencode-path-parser#options","content":"None "},{"title":"Sample usage​","type":1,"pageTitle":"http-urlencode-path-parser","url":"docs/middlewares/http-urlencode-path-parser#sample-usage","content":"import middy from '@middy/core' import httpUrlEncodePathParser from '@middy/http-urlencode-path-parser' const handler = middy((event, context) =&gt; { return event.body // propagates the body as response }) handler.use(httpUrlEncodePathParser()) // When Lambda runs the handler with a sample event... const event = { pathParameters: { name: encodeURIComponent('Mîddy') } } handler(event, {}, (_, body) =&gt; { t.deepEqual(body, { name: 'Mîddy' }) }) Copy "},{"title":"rds-signer","type":0,"sectionRef":"#","url":"docs/middlewares/rds-signer","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"rds-signer","url":"docs/middlewares/rds-signer#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/rds-signer Copy "},{"title":"Options​","type":1,"pageTitle":"rds-signer","url":"docs/middlewares/rds-signer#options","content":"AwsClient (object) (default AWS.RDS.Signer): AWS.RDS.Signer class constructor (e.g. that has been instrumented with AWS XRay). Must be from aws-sdk v2.awsClientOptions (object) (optional): Options to pass to AWS.RDS.Signer class constructor.fetchData (object) (required): Mapping of internal key name to API request parameters.disablePrefetch (boolean) (default false): On cold start requests will trigger early if they can. Setting awsClientAssumeRole disables prefetch.cacheKey (string) (default rds-signer): Cache key for the fetched data responses. Must be unique across all middleware.cacheExpiry (number) (default -1): How long fetch data responses should be cached for. -1: cache forever, 0: never cache, n: cache for n ms.setToContext (boolean) (default false): Store role tokens to request.context. NOTES: Lambda is required to have IAM permission for rds-db:connect with a resource like arn:aws:rds-db:#{AWS::Region}:#{AWS::AccountId}:dbuser:${database_resource}/${iam_role} "},{"title":"Sample usage​","type":1,"pageTitle":"rds-signer","url":"docs/middlewares/rds-signer#sample-usage","content":"import middy from '@middy/core' import rdsSigner from '@middy/rds-signer' const handler = middy((event, context) =&gt; { const response = { statusCode: 200, headers: {}, body: JSON.stringify({ message: 'hello world' }) }; return response }) handler .use(rdsSigner({ fetchData: { rdsToken: { region: 'ca-central-1', hostname: '***.rds.amazonaws.com', username: 'iam_role', database: 'postgres', port: 5432 } } })) Copy "},{"title":"s3-object-response","type":0,"sectionRef":"#","url":"docs/middlewares/s3-object-response","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"s3-object-response","url":"docs/middlewares/s3-object-response#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/s3-object-response Copy "},{"title":"Options​","type":1,"pageTitle":"s3-object-response","url":"docs/middlewares/s3-object-response#options","content":"bodyType (string) (required): How to pass in the s3 object through the handler. Can be stream or promise.AwsClient (object) (default AWS.S3): AWS.STS class constructor (e.g. that has been instrumented with AWS XRay). Must be from aws-sdk v2.awsClientOptions (object) (optional): Options to pass to AWS.STS class constructor.awsClientCapture (function) (optional): Enable XRay by passing captureAWSClient from aws-xray-sdk in.httpsCapture (function) (optional): Enable XRay by passing captureHTTPsGlobal from aws-xray-sdk in.disablePrefetch (boolean) (default false): On cold start requests will trigger early if they can. Setting awsClientAssumeRole disables prefetch. NOTES: The response from the handler must match the allowed parameters for S3.writeGetObjectResponse, excluding RequestRoute and RequestToken.Lambda is required to have IAM permission for s3-object-lambda:WriteGetObjectResponse "},{"title":"Sample usage​","type":1,"pageTitle":"s3-object-response","url":"docs/middlewares/s3-object-response#sample-usage","content":""},{"title":"Stream​","type":1,"pageTitle":"s3-object-response","url":"docs/middlewares/s3-object-response#stream","content":"import zlib from 'zlib' import middy from '@middy/core' import s3ObjectResponse from '@middy/s3-object-response' const handler = middy((event, context) =&gt; { const readStream = context.s3Object const transformStream = zlib.createBrotliCompress() return { Body: readStream.pipe(transformStream) } }) handler .use(s3ObjectResponse({ bodyType: 'stream' })) Copy "},{"title":"Promise​","type":1,"pageTitle":"s3-object-response","url":"docs/middlewares/s3-object-response#promise","content":"import zlib from 'zlib' import middy from '@middy/core' import s3ObjectResponse from '@middy/s3-object-response' const handler = middy(async (event, context) =&gt; { let body = await context.s3Object // change body return { Body: JSON.stringify(body) } }) handler .use(s3ObjectResponse({ bodyType: 'promise' })) Copy "},{"title":"secrets-manager","type":0,"sectionRef":"#","url":"docs/middlewares/secrets-manager","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"secrets-manager","url":"docs/middlewares/secrets-manager#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/secrets-manager Copy "},{"title":"Options​","type":1,"pageTitle":"secrets-manager","url":"docs/middlewares/secrets-manager#options","content":"AwsClient (object) (default AWS.SecretsManager): AWS.SecretsManager class constructor (e.g. that has been instrumented with AWS XRay). Must be from aws-sdk v2.awsClientOptions (object) (optional): Options to pass to AWS.SecretsManager class constructor.awsClientAssumeRole (string) (optional): Internal key where secrets are stored. See @middy/sts on to set this.awsClientCapture (function) (optional): Enable XRay by passing captureAWSClient from aws-xray-sdk in.fetchData (object) (required): Mapping of internal key name to API request parameter SecretId.disablePrefetch (boolean) (default false): On cold start requests will trigger early if they can. Setting awsClientAssumeRole disables prefetch.cacheKey (string) (default secrets-manager): Cache key for the fetched data responses. Must be unique across all middleware.cacheExpiry (number) (default -1): How long fetch data responses should be cached for. -1: cache forever, 0: never cache, n: cache for n ms.setToContext (boolean) (default false): Store secrets to request.context. NOTES: Lambda is required to have IAM permission for secretsmanager:GetSecretValue "},{"title":"Sample usage​","type":1,"pageTitle":"secrets-manager","url":"docs/middlewares/secrets-manager#sample-usage","content":"import middy from '@middy/core' import secretsManager from '@middy/secrets-manager' const handler = middy((event, context) =&gt; { return {} }) handler.use(secretsManager({ fetchData: { apiToken: 'dev/api_token' }, awsClientOptions: { region: 'us-east-1', }, setToContext: true, })) // Before running the function handler, the middleware will fetch from Secrets Manager handler(event, context, (_, response) =&gt; { // assuming the dev/api_token has two keys, 'Username' and 'Password' t.is(context.apiToken.Username,'username') t.is(context.apiToken.Password,'password') }) Copy "},{"title":"service-discovery","type":0,"sectionRef":"#","url":"docs/middlewares/service-discovery","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"service-discovery","url":"docs/middlewares/service-discovery#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/service-discovery Copy "},{"title":"Options​","type":1,"pageTitle":"service-discovery","url":"docs/middlewares/service-discovery#options","content":"AwsClient (object) (default AWS.STS): AWS.STS class constructor (e.g. that has been instrumented with AWS XRay). Must be from aws-sdk v2.awsClientOptions (object) (default undefined): Options to pass to AWS.STS class constructor.awsClientAssumeRole (string) (default undefined): Internal key where secrets are stored. See @middy/sts on to set this.awsClientCapture (function) (default undefined): Enable XRay by passing captureAWSClient from aws-xray-sdk in.fetchData (object) (required): Mapping of internal key name to API request parameters.disablePrefetch (boolean) (default false): On cold start requests will trigger early if they can. Setting awsClientAssumeRole disables prefetch.cacheKey (string) (default sts): Cache key for the fetched data responses. Must be unique across all middleware.cacheExpiry (number) (default -1): How long fetch data responses should be cached for. -1: cache forever, 0: never cache, n: cache for n ms.setToContext (boolean) (default false): Store credentials to request.context. NOTES: Lambda is required to have IAM permission for servicediscovery:DiscoverInstances "},{"title":"Sample usage​","type":1,"pageTitle":"service-discovery","url":"docs/middlewares/service-discovery#sample-usage","content":"import middy from '@middy/core' import serviceDiscovery from '@middy/service-discovery' const handler = middy((event, context) =&gt; { const response = { statusCode: 200, headers: {}, body: JSON.stringify({ message: 'hello world' }) }; return response }) handler .use(serviceDiscovery({ fetchData: { instances: { NamespaceName: '...', ServiceName:'...' } } })) Copy "},{"title":"sqs-partial-batch-failure","type":0,"sectionRef":"#","url":"docs/middlewares/sqs-partial-batch-failure","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"sqs-partial-batch-failure","url":"docs/middlewares/sqs-partial-batch-failure#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/sqs-partial-batch-failure Copy "},{"title":"Options​","type":1,"pageTitle":"sqs-partial-batch-failure","url":"docs/middlewares/sqs-partial-batch-failure#options","content":"AwsClient (object) (default AWS.SQS): AWS.SQS class constructor (e.g. that has been instrumented with AWS XRay). Must be from aws-sdk v2.awsClientOptions (object) (optional): Options to pass to AWS.SQS class constructor.awsClientAssumeRole (string) (optional): Internal key where role tokens are stored. See @middy/sts on to set this.awsClientCapture (function) (optional): Enable XRay by passing captureAWSClient from aws-xray-sdk in.disablePrefetch (boolean) (default false): On cold start requests will trigger early if they can. Setting awsClientAssumeRole disables prefetch. NOTES: Lambda is required to have IAM permission for sqs:DeleteMessage "},{"title":"Sample usage​","type":1,"pageTitle":"sqs-partial-batch-failure","url":"docs/middlewares/sqs-partial-batch-failure#sample-usage","content":"import middy from '@middy/core' import sqsBatch from '@middy/sqs-partial-batch-failure' const baseHandler = (event, context) =&gt; { const recordPromises = event.Records.map(async (record, index) =&gt; { /* Custom message processing logic */ return record }) return Promise.allSettled(recordPromises) } const handler = middy(baseHandler) .use(sqsBatch()) Copy "},{"title":"sts","type":0,"sectionRef":"#","url":"docs/middlewares/sts","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"sts","url":"docs/middlewares/sts#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/sts Copy "},{"title":"Options​","type":1,"pageTitle":"sts","url":"docs/middlewares/sts#options","content":"AwsClient (object) (default AWS.STS): AWS.STS class constructor (e.g. that has been instrumented with AWS XRay). Must be from aws-sdk v2.awsClientOptions (object) (optional): Options to pass to AWS.STS class constructor.awsClientCapture (function) (optional): Enable XRay by passing captureAWSClient from aws-xray-sdk in.fetchData (object) (required): Mapping of internal key name to API request parameters.disablePrefetch (boolean) (default false): On cold start requests will trigger early if they can. Setting awsClientAssumeRole disables prefetch.cacheKey (string) (default sts): Cache key for the fetched data responses. Must be unique across all middleware.cacheExpiry (number) (default -1): How long fetch data responses should be cached for. -1: cache forever, 0: never cache, n: cache for n ms.setToContext (boolean) (default false): Store credentials to request.context. NOTES: Lambda is required to have IAM permission for sts:AssumeRolesetToContext are included for legacy support and should be avoided for performance and security reasons. See main documentation for best practices. "},{"title":"Sample usage​","type":1,"pageTitle":"sts","url":"docs/middlewares/sts#sample-usage","content":"import middy from '@middy/core' import sts from '@middy/sts' const handler = middy((event, context) =&gt; { const response = { statusCode: 200, headers: {}, body: JSON.stringify({ message: 'hello world' }) }; return response }) handler .use(sts({ fetchData: { assumeRole: { RoleArn: '...', RoleSessionName:'' // optional } } })) Copy "},{"title":"ssm","type":0,"sectionRef":"#","url":"docs/middlewares/ssm","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"ssm","url":"docs/middlewares/ssm#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/ssm Copy "},{"title":"Options​","type":1,"pageTitle":"ssm","url":"docs/middlewares/ssm#options","content":"AwsClient (object) (default AWS.SSM): AWS.SSM class constructor (e.g. that has been instrumented with AWS X-Ray). Must be from aws-sdk v2.awsClientOptions (object) (optional): Options to pass to AWS.SSM class constructor.awsClientAssumeRole (string) (optional): Internal key where role tokens are stored. See @middy/sts on to set this.awsClientCapture (function) (optional): Enable AWS X-Ray by passing captureAWSClient from aws-xray-sdk in.fetchData (object) (required): Mapping of internal key name to API request parameter Names/Path. SecureString are automatically decrypted.disablePrefetch (boolean) (default false): On cold start requests will trigger early if they can. Setting awsClientAssumeRole disables prefetch.cacheKey (string) (default ssm): Cache key for the fetched data responses. Must be unique across all middleware.cacheExpiry (number) (default -1): How long fetch data responses should be cached for. -1: cache forever, 0: never cache, n: cache for n ms.setToContext (boolean) (default false): Store role tokens to request.context. NOTES: Lambda is required to have IAM permission for ssm:GetParameters and/or ssm:GetParametersByPath depending on what you're requesting.SSM has throughput limitations. Switching to Advanced Parameter type or increasing maxRetries and retryDelayOptions.base in awsClientOptions may be required. "},{"title":"Sample usage​","type":1,"pageTitle":"ssm","url":"docs/middlewares/ssm#sample-usage","content":"import middy from '@middy/core' import ssm from '@middy/ssm' const handler = middy((event, context) =&gt; { return {} }) let globalDefaults = {} handler .use(ssm({ fetchData: { accessToken: '/dev/service_name/access_token', // single value dbParams: '/dev/service_name/database/', // object of values, key for each path defaults: '/dev/defaults' }, setToContext: true })) .before((request) =&gt; { globalDefaults = request.context.defaults.global }) Copy import middy from '@middy/core' import {getInternal} from '@middy/util' import ssm from '@middy/ssm' const handler = middy((event, context) =&gt; { return {} }) let globalDefaults = {} handler .use(ssm({ fetchData: { defaults: '/dev/defaults' }, cacheKey: 'ssm-defaults' })) .use(ssm({ fetchData: { accessToken: '/dev/service_name/access_token', // single value dbParams: '/dev/service_name/database/', // object of values, key for each path }, cacheExpiry: 15*60*1000, cacheKey: 'ssm-secrets' })) // ... other middleware that fetch .before(async (request) =&gt; { const data = await getInternal(['accessToken','dbParams','defaults'], request) Object.assign(request.context, data) }) Copy "},{"title":"Third-party middlewares","type":0,"sectionRef":"#","url":"docs/middlewares/third-party","content":"","keywords":""},{"title":"Version 2.x​","type":1,"pageTitle":"Third-party middlewares","url":"docs/middlewares/third-party#version-2x","content":"middy-ajv: AJV validator optimized for performancemiddy-sparks-joi: Joi validatormiddy-idempotent: idempotency middleware for middymiddy-jsonapi: JSONAPI middleware for middymiddy-lesslog: Middleware for lesslog, a teeny-tiny and severless-ready logging utilitymiddy-rds: Creates RDS connection using knex or pgmiddy-recaptcha: reCAPTCHA validation middlewaremiddy-event-loop-tracer: Middleware for dumping active tasks with their stacktraces in the event queue just before AWS Lambda function timeouts. So you can understand what was going on in the function when timeout happens.middy-console-logger: Middleware for filtering logs printed over console logging methods. If the level of the console logging method is equal or bigger than configured level, the log is printed, Otherwise, it is ignored.middy-invocation: Middleware for accessing current AWS Lambda invocation event and context from anywhere without need to passing event and context as arguments through your code.middy-profiler: Middleware for profiling CPU on AWS Lambda during invocation and shows what methods/modules consume what percent of CPU time "},{"title":"Version 1.x​","type":1,"pageTitle":"Third-party middlewares","url":"docs/middlewares/third-party#version-1x","content":"middy-redis: Redis connection middlewaremiddy-extractor: Extracts data from events using expressions@keboola/middy-error-logger: middleware that catches thrown exceptions and rejected promises and logs them comprehensibly to the console@keboola/middy-event-validator: Joi powered event validation middlewaremiddy-reroute: provides complex redirect, rewrite and proxying capabilities by simply placing a rules file into your S3 bucketmiddytohof: Convert Middy middleware plugins to higher-order functions returning lambda handlerswrap-ware: A middleware wrapper which works with promises / asyncmiddy-middleware-warmup: A middy plugin to help keep your Lambdas warm during Winter@sharecover-co/middy-aws-xray-tracing: AWS X-Ray Tracing Middleware@sharecover-co/middy-http-response-serializer: This middleware serializes the response to JSON and wraps it in a 200 HTTP response@seedrs/middyjs-middleware: Collection of useful middlewaresmiddy-autoproxyresponse: A middleware that lets you return simple JavaScript objects from Lambda function handlers and converts them into LAMBDA_PROXY responsesjwt-auth: JSON web token authorization middleware based on express-jwtmiddy-mongoose-connector: MongoDB connection middleware for mongoose.js@ematipico/middy-request-response: a middleware that creates a pair of request/response objects@marcosantonocito/middy-cognito-permission: Authorization and roles permission management for the Middy framework that works with Amazon Cognitomiddy-env: Fetch, validate and type cast environment variablessqs-json-body-parser: Parse the SQS body to JSONmiddy-lesslog: Middleware for lesslog, a teeny-tiny and severless-ready logging utility "},{"title":"warmup","type":0,"sectionRef":"#","url":"docs/middlewares/warmup","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"warmup","url":"docs/middlewares/warmup#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/warmup Copy "},{"title":"Options​","type":1,"pageTitle":"warmup","url":"docs/middlewares/warmup#options","content":"isWarmingUp: a function that accepts the event object as a parameter and returns true if the current event is a warmup event and false if it's a regular execution. The default function will check if the event object has a source property set to serverless-plugin-warmup. "},{"title":"Sample usage​","type":1,"pageTitle":"warmup","url":"docs/middlewares/warmup#sample-usage","content":"const middy = require('@middy/core') const warmup = require('@middy/warmup') const isWarmingUp = (event) =&gt; event.isWarmingUp === true const originalHandler = (event, context, cb) =&gt; { /* ... */ } const handler = middy(originalHandler) .use(warmup({ isWarmingUp })) Copy "},{"title":"validator","type":0,"sectionRef":"#","url":"docs/middlewares/validator","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"validator","url":"docs/middlewares/validator#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/validator Copy "},{"title":"Options​","type":1,"pageTitle":"validator","url":"docs/middlewares/validator#options","content":"inputSchema (object) (optional): The JSON schema object or compiled ajv validator that will be used to validate the input (request.event) of the Lambda handler.outputSchema (object) (optional): The JSON schema object or compiled ajv validator that will be used to validate the output (request.response) of the Lambda handler.ajvOptions (object) (optional): Options to pass to ajvclass constructor. Defaults are { strict: true, coerceTypes: 'array', allErrors: true, useDefaults: 'empty', messages: false, defaultLanguage: 'en' }. NOTES: At least one of inputSchema or outputSchema is required.Important Compiling schemas on the fly will cause a 50-100ms performance hit during cold start for simple JSON Schemas. Precompiling is highly recommended.Default ajv plugins used: ajv-i18n, ajv-formats, ajv-formats-draft2019If you'd like to have the error details as part of the response, it will need to be handled separately. You can access them from request.error.details, the original response can be found at request.error.response.  "},{"title":"Sample usage​","type":1,"pageTitle":"validator","url":"docs/middlewares/validator#sample-usage","content":"Example for input validation: import middy from '@middy/core' import validator from '@middy/validator' const handler = middy((event, context) =&gt; { return {} }) const schema = { required: ['body', 'foo'], properties: { // this will pass validation body: { type: 'string' }, // this won't as it won't be in the event foo: { type: 'string' } } } handler.use(validator({ inputSchema: schema })) // invokes the handler, note that property foo is missing const event = { body: JSON.stringify({something: 'somethingelse'}) } handler(event, {}, (err, res) =&gt; { t.is(err.message,'Event object failed validation') }) Copy Example for output validation: import middy from '@middy/core' import validator from '@middy/validator' const handler = middy((event, context) =&gt; { return {} }) const schema = { required: ['body', 'statusCode'], properties: { body: { type: 'object' }, statusCode: { type: 'number' } } } handler.use(validator({outputSchema: schema})) handler({}, {}, (err, response) =&gt; { t.not(err, null) t.is(err.message,'Response object failed validation') expect(response).not.toBe(null) // it doesn't destroy the response so it can be used by other middlewares }) Copy "},{"title":"ws-json-body-parser","type":0,"sectionRef":"#","url":"docs/middlewares/ws-json-body-parser","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"ws-json-body-parser","url":"docs/middlewares/ws-json-body-parser#install","content":"To install this middleware you can use NPM: npm install --save @middy/ws-json-body-parser Copy "},{"title":"Options​","type":1,"pageTitle":"ws-json-body-parser","url":"docs/middlewares/ws-json-body-parser#options","content":"reviver (function) (default undefined): A reviver parameter may be passed which will be used JSON.parseing the body. "},{"title":"Sample usage​","type":1,"pageTitle":"ws-json-body-parser","url":"docs/middlewares/ws-json-body-parser#sample-usage","content":"import middy from '@middy/core' import wsJsonBodyParserMiddleware from '@middy/ws-json-body-parser' import wsResponseMiddleware from '@middy/ws-response' export const handler = middy() .use(wsJsonBodyParserMiddleware()) .use(wsResponseMiddleware()) .handler((event) =&gt; { return event.body.message }) Copy "},{"title":"ws-response","type":0,"sectionRef":"#","url":"docs/middlewares/ws-response","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"ws-response","url":"docs/middlewares/ws-response#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/ws-responder Copy "},{"title":"Options​","type":1,"pageTitle":"ws-response","url":"docs/middlewares/ws-response#options","content":"AwsClient (object) (default AWS.ApiGatewayManagementApi): AWS.ApiGatewayManagementApi class constructor (e.g. that has been instrumented with AWS XRay). Must be from aws-sdk v2.awsClientOptions (object) (default undefined): Options to pass to AWS.ApiGatewayManagementApi class constructor.awsClientAssumeRole (string) (default undefined): Internal key where secrets are stored. See @middy/sts on to set this.awsClientCapture (function) (default undefined): Enable XRay by passing captureAWSClient from aws-xray-sdk in.disablePrefetch (boolean) (default false): On cold start requests will trigger early if they can. Setting awsClientAssumeRole disables prefetch. NOTES: Lambda is required to have IAM permission for execute-api:ManageConnectionsIf awsClientOptions.endpoint is not set it will be set using event.requestContext.{domainName,stage}If response does not contain ConnectId, it will be set from event.requestContext.connectionId "},{"title":"Sample usage​","type":1,"pageTitle":"ws-response","url":"docs/middlewares/ws-response#sample-usage","content":""},{"title":"API Gateway​","type":1,"pageTitle":"ws-response","url":"docs/middlewares/ws-response#api-gateway","content":"import middy from '@middy/core' import wsResonse from '@middy/ws-responder' export const handler = middy((event, context) =&gt; { return 'message' }) handler .use(wsResonse()) Copy "},{"title":"General​","type":1,"pageTitle":"ws-response","url":"docs/middlewares/ws-response#general","content":"import middy from '@middy/core' import wsResonse from '@middy/ws-responder' export const handler = middy((event, context) =&gt; { return { ConnectionId: '...', Data: 'message' } }) handler .use(wsResonse({ awsClientOptions: { endpoint: '...' } })) Copy "},{"title":"http-router","type":0,"sectionRef":"#","url":"docs/routers/http-router","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"http-router","url":"docs/routers/http-router#install","content":"To install this middleware you can use NPM: npmYarn npm install --save @middy/http-router Copy "},{"title":"Options​","type":1,"pageTitle":"http-router","url":"docs/routers/http-router#options","content":"routes (array[{method, path, handler}]) (required): Array of route objects. method (string) (required): One of GET, POST, PUT, PATCH, DELETE, OPTIONS and ANY that will match to any method passed inpath (string) (required): AWS formatted path starting with /. Variable: /{id}/, Wildcard: /{proxy+}handler (function) (required): Any handler(event, context) function NOTES: Errors should be handled as part of the router middleware stack or the lambdaHandler middleware stack. Handled errors in the later will trigger the after middleware stack of the former.Shared middlewares, connected to the router middleware stack, can only be run before the lambdaHandler middleware stack. "},{"title":"Sample usage​","type":1,"pageTitle":"http-router","url":"docs/routers/http-router#sample-usage","content":"import middy from '@middy/core' import httpRouterHandler from '@middy/http-router' import validatorMiddleware from '@middy/validator' const getHandler = middy() .use(validatorMiddleware({inputSchema: {...} })) .handler((event, context) =&gt; { return { statusCode: 200, body: '{...}' } }) const postHandler = middy() .use(validatorMiddleware({inputSchema: {...} })) .handler((event, context) =&gt; { return { statusCode: 200, body: '{...}' } }) const routes = [ { method: 'GET', path: '/user/{id}', handler: getHandler }, { method: 'POST', path: '/user', handler: postHandler } ] export const handler = middy() .use(httpHeaderNormalizer()) .handler(httpRouterHandler(routes)) Copy "},{"title":"ws-router","type":0,"sectionRef":"#","url":"docs/routers/ws-router","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"ws-router","url":"docs/routers/ws-router#install","content":"To install this middleware you can use NPM: npm install --save @middy/ws-router Copy "},{"title":"Options​","type":1,"pageTitle":"ws-router","url":"docs/routers/ws-router#options","content":"routes (array[{method, path, handler}]) (required): Array of route objects. routeKey (string) (required): AWS formatted route key. ie $connect, $disconnect, $defaulthandler (function) (required): Any handler(event, context, {signal}) function NOTES: Errors should be handled as part of the router middleware stack or the lambdaHandler middleware stack. Handled errors in the later will trigger the after middleware stack of the former.Shared middlewares, connected to the router middleware stack, can only be run before the lambdaHandler middleware stack. "},{"title":"Sample usage​","type":1,"pageTitle":"ws-router","url":"docs/routers/ws-router#sample-usage","content":"import middy from '@middy/core' import wsRouterHandler from '@middy/ws-router' import wsResponseMiddleware from '@middy/ws-response' import validatorMiddleware from '@middy/validator' const connectHandler = middy() .use(validatorMiddleware({inputSchema: {...} })) .handler((event, context) =&gt; { return 'connected' }) const disconnectHandler = middy() .use(validatorMiddleware({inputSchema: {...} })) .handler((event, context) =&gt; { return 'disconnected' }) handler = middy() .use(wsResponseMiddleware()) .handler(wsRouterHandler([ { routeKey: '$connect', handler: connectHandler }, { routeKey: '$disconnect', handler: disconnectHandler } ])) module.exports = { handler } Copy "},{"title":"Configurable Middlewares","type":0,"sectionRef":"#","url":"docs/writing-middlewares/configurable-middlewares","content":"Configurable Middlewares In order to make middlewares configurable, they are generally exported as a function that accepts a configuration object. This function should then return the middleware object with before,after, and onError as keys. E.g. // customMiddleware.js const defaults = {} const customMiddleware = (opts) =&gt; { const options = { ...defaults, ...opts } const customMiddlewareBefore = async (request) =&gt; { const { event, context } = request // ... } const customMiddlewareAfter = async (request) =&gt; { const { response } = request // ... request.response = response } const customMiddlewareOnError = async (request) =&gt; { if (request.response === undefined) return return customMiddlewareAfter(request) } return { before: customMiddlewareBefore, after: customMiddlewareAfter, onError: customMiddlewareOnError } } export default customMiddleware Copy With this convention in mind, using a middleware will always look like the following example: import middy from '@middy/core' import customMiddleware from 'customMiddleware.js' const lambdaHandler = async (event, context) =&gt; { // do stuff return {} } export const handler = middy(lambdaHandler) .use(customMiddleware({ option1: 'foo', option2: 'bar' })) Copy","keywords":""},{"title":"Inline Middlewares","type":0,"sectionRef":"#","url":"docs/writing-middlewares/inline-middlewares","content":"Inline Middlewares Sometimes you want to create handlers that serve a very small need and that are not necessarily re-usable. In such cases, you probably will need to hook only into one of the different phases (before, after or onError). In these cases you can use inline middlewares which are shortcut functions to hook logic into Middy's control flow. Let's see how inline middlewares work with a simple example: import middy from '@middy/core' export const handler = middy((event, context) =&gt; { // do stuff }) .before(async (request) =&gt; { // do something in the before phase }) .after(async (request) =&gt; { // do something in the after phase }) .onError(async (request) =&gt; { // do something in the on error phase }) Copy As you can see above, a middy instance also exposes the before, after and onErrormethods to allow you to quickly hook in simple inline middlewares.","keywords":""},{"title":"Custom Middlewares","type":0,"sectionRef":"#","url":"docs/writing-middlewares/intro","content":"Custom Middlewares A middleware is an object that should contain at least 1 of 3 possible keys: before: a function that is executed in the before phaseafter: a function that is executed in the after phaseonError: a function that is executed in case of errors before, after and onError functions need to have the following signature: async (request) =&gt; { // ... } Copy Where: request: is a reference to the current context and allows access to (and modification of) the current event (request), the response (in the after phase), and error(in case of an error).","keywords":""},{"title":"Internal Storage","type":0,"sectionRef":"#","url":"docs/writing-middlewares/internal-storage","content":"Internal Storage The handler also contains an internal object that can be used to store values securely between middlewares that expires when the event ends. To compliment this there is also a cache where middleware can store request promises. During before these promises can be stored into internal then resolved only when needed. This pattern is useful to take advantage of the async nature of node especially when you have multiple middleware that require reaching out the external APIs. Here is a middleware boilerplate using this pattern: import { canPrefetch, getInternal, processCache } from '@middy/util' const defaults = { fetchData: {}, // { internalKey: params } disablePrefetch: false, cacheKey: 'custom', cacheExpiry: -1, setToContext: false } module.exports = (opts = {}) =&gt; { const options = { ...defaults, ...opts } const fetch = () =&gt; { const values = {} // Start your custom fetch for (const internalKey of Object.keys(options.fetchData)) { values[internalKey] = fetch('...', options.fetchData[internalKey]).then(res =&gt; res.text()) } // End your custom fetch return values } let prefetch, client, init if (canPrefetch(options)) { init = true prefetch = processCache(options, fetch) } const customMiddlewareBefore = async (request) =&gt; { let cached if (init) { cached = prefetch } else { cached = processCache(options, fetch, request) } Object.assign(request.internal, cached) if (options.setToContext) Object.assign(request.context, await getInternal(Object.keys(options.fetchData), request)) else init = false } return { before: customMiddlewareBefore } } Copy","keywords":""},{"title":"More Examples","type":0,"sectionRef":"#","url":"docs/writing-middlewares/more-examples","content":"More Examples Check the code for existing middlewares to see more examples on how to write a middleware.","keywords":""},{"title":"With TypeScript","type":0,"sectionRef":"#","url":"docs/writing-middlewares/with-typescript","content":"With TypeScript here's an example of how you can write a custom middleware for a Lambda receiving events from API Gateway: import middy from '@middy/core' import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda' const middleware = (): middy.MiddlewareObj&lt;APIGatewayProxyEvent, APIGatewayProxyResult&gt; =&gt; { const before: middy.MiddlewareFn&lt;APIGatewayProxyEvent, APIGatewayProxyResult&gt; = async ( request ): Promise&lt;void&gt; =&gt; { // Your middleware logic } const after: middy.MiddlewareFn&lt;APIGatewayProxyEvent, APIGatewayProxyResult&gt; = async ( request ): Promise&lt;void&gt; =&gt; { // Your middleware logic } return { before, after } } export default middleware Copy Note: The Middy core team does not use TypeScript often and we can't certainly claim that we are TypeScript experts. We tried our best to come up with type definitions that should give TypeScript users a good experience. There is certainly room for improvement, so we would be more than happy to receive contributions 😊 See devDependencies for each middleware for list of dependencies that may be required with transpiling TypeScript.","keywords":""}]